const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BdgVNXf3.js","assets/web3-vendor-D-smDdvq.js","assets/react-vendor-oRnAdrvc.js","assets/ui-vendor-DvZrbspg.js","assets/index-afkGx5Ck.css"])))=>i.map(i=>d[i]);
import{_ as e}from"./web3-vendor-D-smDdvq.js";import{bp as t,z as r,E as a,G as s,bq as i,a2 as n,aj as o,b4 as l,ad as f,B as u,ac as c,bo as h,br as m,af as p,aL as d,ab as y,a8 as g,b5 as b,ai as w,bs as v,t as S,bt as x,bu as T,bv as P,a_ as C,ae as B,bw as A,bx as k,H as L,by as I}from"./index-BdgVNXf3.js";import{r as O,t as H}from"./treeify-PLB7ybit.js";import{E as R,S as E}from"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import{N as U}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import{g as N}from"./react-vendor-oRnAdrvc.js";var M=t();class j{print(){j.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(e,t,M.Buffer.compare);return this.linearSearch(e,t,((e,t)=>e.equals(t)))}static binarySearch(e,t,r){let a=0,s=e.length-1;for(;a<=s;){const i=Math.floor((a+s)/2),n=r(e[i],t);if(0===n){for(let a=i-1;a>=0;a--)if(0!==r(e[a],t))return a+1;return 0}n<0?a=i+1:s=i-1}return-1}binarySearch(e,t,r){return j.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let a=0;a<e.length;a++)if(r(e[a],t))return a;return-1}linearSearch(e,t,r){return j.linearSearch(e,t,r)}static bufferify(e){if(!M.Buffer.isBuffer(e)){if("object"==typeof e&&e.words)return M.Buffer.from(e.toString(D),"hex");if(j.isHexString(e))return M.Buffer.from(e.replace(/^0x/,""),"hex");if("string"==typeof e)return M.Buffer.from(e);if("bigint"==typeof e)return M.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return M.Buffer.from(e.buffer);if("number"==typeof e){let t=e.toString();return t.length%2&&(t=`0${t}`),M.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return M.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return j.bigNumberify(e)}static bigNumberify(e){if("bigint"==typeof e)return e;if("string"==typeof e)return e.startsWith("0x")&&j.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(M.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){const t=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${t}`)}(e);if("number"==typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"==typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){}bufferToHex(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return j.bufferToHex(e,t)}static bufferToHex(e){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(e||M.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return j.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(M.Buffer.isBuffer(r))return r;if(this.isHexString(r))return M.Buffer.from(r.replace("0x",""),"hex");if("string"==typeof r)return M.Buffer.from(r);if("bigint"==typeof r)return M.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return M.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex")),s=function(e){const t=new Uint8Array(e);return Array.from(t).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e(a));return M.Buffer.from(s,"hex")}}isHexString(e){return j.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map(((e,r)=>[e,t[r]]))}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var F=j;function D(e){const t=e.words,r=new ArrayBuffer(4*t.length),a=new Uint8Array(r);for(let s=0;s<t.length;s++)a[4*s]=t[s]>>24&255,a[4*s+1]=t[s]>>16&255,a[4*s+2]=t[s]>>8&255,a[4*s+3]=255&t[s];return r}class W extends F{duplicateOdd=!1;concatenator=M.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!M.Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(M.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=r){this.layers[t].push(...e.slice(r));break}if(a+1===e.length&&e.length%2==1){const r=e[e.length-1];let s=r;if(this.isBitcoinTree){s=this.hashFn(this.concatenator([O(r),O(r)])),s=O(this.hashFn(s)),this.layers[t].push(s);continue}if(!this.duplicateOdd){this.layers[t].push(e[a]);continue}}const s=e[a],i=a+1===e.length?s:e[a+1];let n=null;n=this.isBitcoinTree?[O(s),O(i)]:[s,i],this.sortPairs&&n.sort(M.Buffer.compare);let o=this.hashFn(this.concatenator(n));this.isBitcoinTree&&(o=O(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(M.Buffer.compare))),this.leaves.filter((t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves)))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?M.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){if(t[r].equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((e=>this.bufferToHex(e)))}static marshalLeaves(e){return JSON.stringify(e.map((e=>W.bufferToHex(e))),null,2)}static unmarshalLeaves(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(W.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((e,t)=>(Array.isArray(t)?e.push(t.map((e=>this.bufferToHex(e)))):e.push(t),e)),[])}getLayersFlat(){const e=this.layers.reduce(((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e)),[]);return e.unshift(M.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map((e=>this.bufferToHex(e)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?M.Buffer.from([]):this.layers[this.layers.length-1][0]||M.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(void 0===e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===M.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let a=0;a<this.layers.length;a++){const e=this.layers[a],s=t%2,i=s?t-1:this.isBitcoinTree&&t===e.length-1&&a<this.layers.length-1?t:t+1;i<e.length&&r.push({position:s?"left":"right",data:e[i]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map((e=>this.bufferToHex(e.data)))}getProofs(){const e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,a){const s=t%2;if(-1===e)return void(s||a.push([...r].reverse()));if(t>=this.layers[e].length)return;const i=this.layers[e],n=s?t-1:t+1;let o=!1;n<i.length&&(o=!0,r.push({position:s?"left":"right",data:i[n]}));const l=2*t,f=2*t+1;this.getProofsDFS(e-1,l,r,a),this.getProofsDFS(e-1,f,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((e=>this.bufferToHex(e.data)))}getPositionalHexProof(e,t){return this.getProof(e,t).map((e=>["left"===e.position?0:1,this.bufferToHex(e.data)]))}getProofIndices(e,t){const r=2**t;let a=new Set;for(const l of e){let e=r+l;for(;e>1;)a.add(1^e),e=e/2|0}const s=e.map((e=>r+e)),i=Array.from(a).sort(((e,t)=>e-t)).reverse();a=s.concat(i);const n=new Set,o=[];for(let l of a)if(!n.has(l))for(o.push(l);l>1&&(n.add(l),n.has(1^l));)l=l/2|0;return o.filter((t=>!e.includes(t-r)))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),a=[];for(let n=0;n<r;n++){t%2!=0&&a.push({index:n,leavesCount:t}),t=Math.ceil(t/2)}const s=[];let i=e;for(let n=0;n<r;n++){let e=i.map((e=>e%2==0?e+1:e-1)).filter((e=>!i.includes(e)));const t=a.find((e=>{let{index:t}=e;return t===n}));t&&i.includes(t.leavesCount-1)&&(e=e.slice(0,-1)),s.push(e),i=[...new Set(i.map((e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2)))]}return s}getMultiProof(e,t){this.complete,t||(t=e,e=this.getLayersFlat());if(this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(M.Buffer.compare));let r=e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1));if(!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const a=[],s=[];let i=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const n=r[t],o=this.getPairNode(e,n);a.push(e[n]),o&&s.push(o),i.push(n/2|0)}r=i.filter(((e,t,r)=>r.indexOf(e)===t)),i=[]}return s.filter((e=>!a.includes(e)))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map((t=>e[t]))}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],a=t;for(const s of e){const e=[];for(const r of a){if(r%2==0){const t=r+1;if(!a.includes(t)&&s[t]){e.push(s[t]);continue}}const t=r-1;a.includes(t)||!s[t]||e.push(s[t])}r=r.concat(e);const t=new Set;for(const r of a)r%2!=0?r%2!=0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);a=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map((e=>this.bufferToHex(e)))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort(((e,t)=>e===t?0:e>t?1:-1)):e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1)),!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const a=t.map((e=>this.bufferify(e))),s=[],i=[];for(let n=0;n<this.layers.length;n++){const e=this.layers[n];r=r.reduce(((t,r)=>{if(!s.includes(e[r])){const t=this.getPairNode(e,r),n=a.includes(e[r])||a.includes(t);t&&i.push(!n),s.push(e[r]),s.push(t)}return t.push(r/2|0),t}),[])}return i}verify(e,t,r){let a=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let s=0;s<e.length;s++){const t=e[s];let r=null,i=null;if("string"==typeof t)r=this.bufferify(t),i=!0;else if(Array.isArray(t))i=0===t[0],r=this.bufferify(t[1]);else if(M.Buffer.isBuffer(t))r=t,i=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),i="left"===t.position}const n=[];this.isBitcoinTree?(n.push(O(a)),n[i?"unshift":"push"](O(r)),a=this.hashFn(this.concatenator(n)),a=O(this.hashFn(a))):this.sortPairs?-1===M.Buffer.compare(a,r)?(n.push(a,r),a=this.hashFn(this.concatenator(n))):(n.push(r,a),a=this.hashFn(this.concatenator(n))):(n.push(a),n[i?"unshift":"push"](r),a=this.hashFn(this.concatenator(n)))}return 0===M.Buffer.compare(a,r)}verifyMultiProof(e,t,r,a,s){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,a,s);const i=Math.ceil(Math.log2(a));e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),s=s.map((e=>this.bufferify(e)));const n={};for(const[f,u]of this.zip(t,r))n[2**i+f]=u;for(const[f,u]of this.zip(this.getProofIndices(t,i),s))n[f]=u;let o=Object.keys(n).map((e=>Number(e))).sort(((e,t)=>e-t));o=o.slice(0,o.length-1);let l=0;for(;l<o.length;){const e=o[l];if(e>=2&&{}.hasOwnProperty.call(n,1^e)){let t=[n[e-e%2],n[e-e%2+1]];this.sortPairs&&(t=t.sort(M.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];n[e/2|0]=r,o.push(e/2|0)}l+=1}return!t.length||{}.hasOwnProperty.call(n,1)&&n[1].equals(e)}verifyMultiProofWithFlags(e,t,r,a){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const s=t.length,i=a.length,n=[];let o=0,l=0,f=0;for(let u=0;u<i;u++){const e=[a[u]?o<s?t[o++]:n[l++]:r[f++],o<s?t[o++]:n[l++]].sort(M.Buffer.compare);n[u]=this.hashFn(this.concatenator(e))}return 0===M.Buffer.compare(n[i-1],e)}verifyMultiProofForUnevenTree(e,t,r,a,s){e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),s=s.map((e=>this.bufferify(e)));const i=this.calculateRootForUnevenTree(t,r,a,s);return e.equals(i)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map((e=>e.map((e=>this.bufferToHex(e,!1))))),t=[];for(let r=0;r<e.length;r++){const a=[];for(let s=0;s<e[r].length;s++){const i={[e[r][s]]:null};if(t.length){i[e[r][s]]={};const a=t.shift(),n=Object.keys(a)[0];if(i[e[r][s]][n]=a[n],t.length){const a=t.shift(),n=Object.keys(a)[0];i[e[r][s]][n]=a[n]}}a.push(i)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2==0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return H.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,a){const s=this.zip(e,t).sort(((e,t)=>{let[r]=e,[a]=t;return r-a})),i=s.map((e=>{let[t]=e;return t})),n=this.getProofIndicesForUnevenTree(i,r);let o=0;const l=[];for(let u=0;u<n.length;u++){const e=n[u],t=o;o+=e.length,l[u]=this.zip(e,a.slice(t,o))}const f=[s];for(let u=0;u<l.length;u++){const e=l[u].concat(f[u]).sort(((e,t)=>{let[r]=e,[a]=t;return r-a})).map((e=>{let[,t]=e;return t})),t=f[u].map((e=>{let[t]=e;return t})),r=[...new Set(t.map((e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2)))],a=[];for(let s=0;s<r.length;s++){const t=r[s],i=e[2*s],n=e[2*s+1],o=n?this.hashFn(this.concatenator([i,n])):i;a.push([t,o])}f.push(a)}return f[f.length-1][0][1]}}let q;const V=new Uint8Array(16);function $(){if(!q&&(q="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!q))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return q(V)}const J=[];for(let Ee=0;Ee<256;++Ee)J.push((Ee+256).toString(16).slice(1));const z={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function _(e,t,r){if(z.randomUUID&&!t&&!e)return z.randomUUID();const a=(e=e||{}).random||(e.rng||$)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=a[e];return t}return function(e,t=0){return J[e[t+0]]+J[e[t+1]]+J[e[t+2]]+J[e[t+3]]+"-"+J[e[t+4]]+J[e[t+5]]+"-"+J[e[t+6]]+J[e[t+7]]+"-"+J[e[t+8]]+J[e[t+9]]+"-"+J[e[t+10]]+J[e[t+11]]+J[e[t+12]]+J[e[t+13]]+J[e[t+14]]+J[e[t+15]]}(a)}function G(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function Y(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function Z(e,t){return"unlimited"===e?c:h(e,t)}async function K(e){const t=25e3,r=Array.from({length:Math.ceil(e.length/t)},((r,a)=>e.slice(a*t,a*t+t))),a=[],s=await Promise.all(r.map((e=>x.parseAsync(e))));for(const i of s)a.push(...i);return a}let Q=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class X{constructor(e,t,r,a,s){this.storage=e,this.shardNybbles=a,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(e,t){try{const r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return X.fromShardedMerkleTreeInfo(r,t)}catch(r){return}}static async fromShardedMerkleTreeInfo(e,t){return new X(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,a){switch(a){case Q.V1:return C(["address","uint256"],[e.address,Z(e.maxClaimable,t)]);case Q.V2:return C(["address","uint256","uint256","address"],[e.address,Z(e.maxClaimable,t),Z(e.price||"unlimited",r),e.currencyAddress||n])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let a=e[r];if(void 0===a){a=(await B(t,r)).decimals,e[r]=a}return a}static async buildAndUpload(e,t,r,a,s){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const n=await K(e),o={};for(const g of n){const e=g.address.slice(2,2+i).toLowerCase();void 0===o[e]&&(o[e]=[]),o[e].push(g)}const l={},f=await Promise.all(Object.entries(o).map((async e=>{let[a,i]=e;return[a,new W(await Promise.all(i.map((async e=>{const a=await X.fetchAndCacheDecimals(l,r,e.currencyAddress);return X.hashEntry(e,t,a,s)}))),A,{sort:!0}).getHexRoot()]}))),u=Object.fromEntries(f),c=new W(Object.values(u),A,{sort:!0}),h=[];for(const[g,b]of Object.entries(o)){const e={proofs:c.getProof(u[g]).map((e=>"0x"+e.data.toString("hex"))),entries:b};h.push({data:JSON.stringify(e),name:`${g}.json`})}const m=await a.uploadBatch(h),p=m[0].slice(0,m[0].lastIndexOf("/")),d=await a.upload(n),y={merkleRoot:c.getHexRoot(),baseUri:p,originalEntriesUri:d,shardNybbles:i,tokenDecimals:t,isShardedMerkleTree:!0};return{shardedMerkleInfo:y,uri:await a.upload(y)}}async getProof(e,t,r){const a=e.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[a];const i={};if(void 0===s)try{const e=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[a]=await this.storage.downloadJSON(`${e}${a}.json`);const n=await Promise.all(s.entries.map((async e=>{const a=await X.fetchAndCacheDecimals(i,t,e.currencyAddress);return X.hashEntry(e,this.tokenDecimals,a,r)})));this.trees[a]=new W(n,A,{sort:!0})}catch(u){return null}const n=s.entries.find((t=>t.address.toLowerCase()===e.toLowerCase()));if(!n)return null;const o=await X.fetchAndCacheDecimals(i,t,n.currencyAddress),l=X.hashEntry(n,this.tokenDecimals,o,r),f=this.trees[a].getProof(l).map((e=>"0x"+e.data.toString("hex")));return k.parseAsync({...n,proof:f.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return[]}}}async function ee(e,t,r,a,s,i){if(!r)return null;const n=r[t];if(n){const r=await s.downloadJSON(n);if(r.isShardedMerkleTree&&r.merkleRoot===t){const t=await X.fromShardedMerkleTreeInfo(r,s);return await t.getProof(e,a,i)}const o=await m.parseAsync(r);if(t===o.merkleRoot)return o.claims.find((t=>t.address.toLowerCase()===e.toLowerCase()))||null}return null}function te(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function re(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function ae(t,r,a,s,i){const n=t.getSigner(),o=t.getProvider(),l=(await e((async()=>{const{default:e}=await import("./index-BdgVNXf3.js").then((e=>e.dV));return{default:e}}),__vite__mapDeps([0,1,2,3,4]))).default,f=new L(n||o,r,l,t.options,t.storage),c=await t.getSignerAddress(),m=t.address,p=await f.read("allowance",[c,m]),d=u.from(a).mul(u.from(s)).div(h("1",i));p.lt(d)&&await f.sendTransaction("approve",[m,p.add(d)])}async function se(e,t,r,a,s,i,o,l,f){let m=Z(r.maxClaimablePerWallet,s),p=[d([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(n)){const t=await ee(e,r.merkleRootHash.toString(),await a(),i.getProvider(),o,f);if(t)p=t.proof,m="unlimited"===t.maxClaimable?c:h(t.maxClaimable,s),b=void 0===t.price||"unlimited"===t.price?c:await y(i.getProvider(),t.price,t.currencyAddress||n),w=t.currencyAddress||n;else if(f===Q.V1)throw new Error("No claim found for this address")}}catch(T){if("No claim found for this address"===T?.message)throw T}const v=await i.getCallOverrides()||{},S=b.toString()!==c.toString()?b:r.price,x=w!==n?w:r.currencyAddress;return S.gt(0)&&(g(x)?v.value=u.from(S).mul(t).div(h("1",s)):l&&await ae(i,x,S,t,s)),{overrides:v,proofs:p,maxClaimable:m,price:S,currencyAddress:x,priceInProof:b,currencyAddressInProof:w}}const ie=(()=>r.object({name:r.string(),symbol:r.string(),decimals:r.number()}))(),ne=(()=>ie.extend({value:l,displayValue:r.string()}))(),oe=(()=>r.object({name:r.string().optional()}).catchall(r.unknown()))(),le=(()=>r.object({startTime:E,currencyAddress:r.string().default(o),price:a.default(0),maxClaimableSupply:T,maxClaimablePerWallet:T,waitInSeconds:w.default(0),merkleRootHash:P.default(d([0],32)),snapshot:r.optional(x).nullable(),metadata:oe.optional()}))(),fe=(()=>r.array(le))(),ue=(()=>le.extend({availableSupply:T,currentMintSupply:T,currencyMetadata:ne.default({value:u.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:l,waitInSeconds:l,startTime:l.transform((e=>new Date(1e3*e.toNumber()))),snapshot:x.optional().nullable()}))();async function ce(e,t,r,a,s){const i=[],n=await Promise.all(e.map((async e=>{if(e.snapshot&&e.snapshot.length>0){const n=await async function(e,t,r,a,s){const i=await K(e),n=i.map((e=>e.address));if(new Set(n).size<n.length)throw new I;const o=await X.buildAndUpload(i,t,r,a,s);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(e.snapshot,t,r,a,s);i.push(n),e.merkleRootHash=n.merkleRoot}else e.merkleRootHash=d([0],32);return e})));return{inputsWithSnapshots:n,snapshotInfos:i}}async function he(e,t,r,a,s){const{inputsWithSnapshots:i,snapshotInfos:l}=await ce(e,t,r,a,s),f=await fe.parseAsync(i),c=(await Promise.all(f.map((e=>async function(e,t,r,a){const s=e.currencyAddress===n?o:e.currencyAddress,i=Z(e.maxClaimableSupply,t),l=Z(e.maxClaimablePerWallet,t);let f;return e.metadata&&(f="string"==typeof e.metadata?e.metadata:await a.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:i,supplyClaimed:0,maxClaimablePerWallet:l,pricePerToken:await y(r,e.price,s),currency:s,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:f}}(e,t,r,a))))).sort(((e,t)=>function(e,t){const r=u.from(e),a=u.from(t);return r.eq(a)?0:r.gt(a)?1:-1}(e.startTimestamp,t.startTimestamp)));return{snapshotInfos:l,sortedConditions:c}}async function me(e,t,r){if(!t)return null;const a=t[e];if(a){const t=await r.downloadJSON(a);if(t.isShardedMerkleTree&&t.merkleRoot===e){const e=await X.fromUri(a,r);return e?.getAllEntries()||null}{const r=await m.parseAsync(t);if(e===r.merkleRoot)return r.claims.map((e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress})))}}return null}function pe(e,t){return e.toString()===c.toString()?"unlimited":p(e,t)}async function de(e,t,r,a,s,i){const n=await f(r,e.currency,e.pricePerToken),o=pe(e.maxClaimableSupply,t),l=pe(e.maxClaimablePerWallet,t),c=pe(u.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),h=pe(e.supplyClaimed,t);let m;return e.metadata&&(m=await s.downloadJSON(e.metadata)),ue.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:l,currentMintSupply:h,availableSupply:c,waitInSeconds:e.waitTimeInSecondsBetweenClaims?.toString(),price:u.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:n,merkleRootHash:e.merkleRoot,snapshot:i?await me(e.merkleRoot,a,s):void 0,metadata:m})}async function ye(e,t,r){if(e>=r.length)throw Error(`Index out of bounds - got index: ${e} with ${r.length} conditions`);const a=r[e].currencyMetadata.decimals,s=r[e].price,i=p(s,a),n=await le.parseAsync({...r[e],price:i,...t}),o=await ue.parseAsync({...n,price:s});return r.map(((t,r)=>{let s;s=r===e?o:t;const i=p(s.price,a);return{...s,price:i}}))}let ge=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function be(e){if(void 0===e){const e=Buffer.alloc(16);return _({},e),v(S(e.toString("hex")))}return v(e)}const we=(()=>r.object({to:s.refine((e=>e.toLowerCase()!==n),{message:"Cannot create payload to mint to zero address"}),price:a.default(0),currencyAddress:i.default(o),mintStartTime:E,mintEndTime:R,uid:r.string().optional().transform((e=>be(e))),primarySaleRecipient:s.default(n)}))(),ve=(()=>we.extend({quantity:a}))(),Se=(()=>ve.extend({mintStartTime:l,mintEndTime:l}))(),xe=(()=>we.extend({metadata:U,royaltyRecipient:r.string().default(n),royaltyBps:b.default(0)}))(),Te=(()=>xe.extend({metadata:U.default(""),uri:r.string(),royaltyBps:l,mintStartTime:l,mintEndTime:l}))(),Pe=(()=>xe.extend({metadata:U.default(""),quantity:w}))(),Ce=(()=>Pe.extend({tokenId:w}))(),Be=(()=>Te.extend({tokenId:l,quantity:l}))(),Ae=(()=>xe.extend({metadata:U.default(""),quantity:l.default(1)}))(),ke=(()=>Te.extend({quantity:l.default(1)}))(),Le=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ie=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Oe=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],He=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];const Re=N((function e(t,r){if(t===r)return!0;if(t&&r&&"object"==typeof t&&"object"==typeof r){if(t.constructor!==r.constructor)return!1;var a,s,i;if(Array.isArray(t)){if((a=t.length)!=r.length)return!1;for(s=a;0!=s--;)if(!e(t[s],r[s]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if((a=(i=Object.keys(t)).length)!==Object.keys(r).length)return!1;for(s=a;0!=s--;)if(!Object.prototype.hasOwnProperty.call(r,i[s]))return!1;for(s=a;0!=s--;){var n=i[s];if(!e(t[n],r[n]))return!1}return!0}return t!=t&&r!=r}));export{we as B,ge as C,Oe as M,Ce as S,Be as a,G as b,Z as c,Re as d,Y as e,ee as f,se as g,Q as h,Ae as i,ke as j,Ie as k,te as l,He as m,re as n,ae as o,he as p,ve as q,be as r,Se as s,de as t,ye as u,Le as v};
//# sourceMappingURL=index-voFwA1yT.js.map
