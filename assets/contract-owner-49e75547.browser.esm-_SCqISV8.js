import{_ as t}from"./web3-vendor-D-smDdvq.js";import{h as a}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{M as r,b6 as e,c as s,J as n,T as o,Q as c,y as i,t as p,a_ as d,a$ as h,b7 as l,B as y,_ as f,ab as u,aj as m}from"./index-BdgVNXf3.js";import{C as w}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import{g,f as W}from"./QueryParams-32a56510.browser.esm-CIeLU7Il.js";import{o as I}from"./index-voFwA1yT.js";class b{featureName=r.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return e.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,r]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return e.parseAsync({fee_recipient:a,seller_fee_basis_points:r})}setDefaultRoyaltyInfo=s((async t=>{const r=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...r,...t}),s=await this.metadata._parseAndUploadMetadata(e);if(a("setContractURI",this.contractWrapper)){const t=new n(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[s])];return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=s((async(t,a)=>{const r=e.parse(a);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,r.fee_recipient,r.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class R{constructor(t,a,r,e){this.featureName=r,this.nextTokenIdToMintFn=e,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=s((async(t,a,r,e)=>{if(!r)throw new Error("Password is required");const s=await this.storage.uploadBatch([w.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),n=g(s),c=await this.nextTokenIdToMintFn(),i=await this.storage.uploadBatch(a.map((t=>w.parse(t))),{onProgress:e?.onProgress,rewriteFileNames:{fileStartNumber:c.toNumber()}}),l=g(i),y=await this.contractWrapper.read("getBaseURICount",[]),f=await this.hashDelayRevealPassword(y,r),u=await this.contractWrapper.read("encryptDecrypt",[p(l),f]);let m;if(await this.isLegacyContract())m=u;else{const t=await this.contractWrapper.getChainID(),a=d(["bytes","bytes","uint256"],[p(l),f,t]);m=h.encode(["bytes","bytes32"],[u,a])}return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[i.length,n.endsWith("/")?n:`${n}/`,m],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args.startTokenId,e=a[0].args.endTokenId,s=[];for(let n=r;n.lte(e);n=n.add(1))s.push({id:n,receipt:t});return s}})}));reveal=s((async(t,a)=>{if(!a)throw new Error("Password is required");const r=await this.hashDelayRevealPassword(t,a);try{const a=await this.contractWrapper.callStatic().reveal(t,r);if(!a.includes("://")||!a.endsWith("/"))throw new Error("invalid password")}catch(e){throw new Error("invalid password")}return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,r]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const r=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(r.map((t=>{if(a("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if(a("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),s=e.slice(0,e.length-1),n=await Promise.all(Array.from([0,...s]).map((t=>this.getNftMetadata(t.toString())))),o=await this.isLegacyContract(),c=(await Promise.all(Array.from([...e]).map((t=>o?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(l(t)>0){if(o)return t;return h.decode(["bytes","bytes32"],t)[0]}return t}));return n.map(((t,a)=>({batchId:y.from(a),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,a)=>l(c[a])>0))}async hashDelayRevealPassword(t,a){const r=await this.contractWrapper.getChainID(),e=this.contractWrapper.address;return d(["string","uint256","uint256","address"],[a,r,t,e])}async getNftMetadata(t){return W(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(a("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(a){const r=(await t((async()=>{const{default:t}=await import("./IDelayedRevealDeprecated-JM0269jw.js");return{default:t}}),[])).default,e=new f(this.contractWrapper.address,r,this.contractWrapper.getProvider()),s=await e.functions.encryptedBaseURI(a);return s.length>0?s[0]:"0x"}}async function _(t,a,r,e,s){let n={};const o=e||m,c=(await u(t.getProvider(),a,o)).mul(r);return c.gt(0)&&(o===m?n={value:c}:o!==m&&s&&await I(t,o,c,r,0)),n}class D{featureName=c.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=s((async t=>{const a=await i(t);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})}))}export{b as C,R as D,D as a,_ as c};
//# sourceMappingURL=contract-owner-49e75547.browser.esm-_SCqISV8.js.map
