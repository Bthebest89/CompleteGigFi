{"version":3,"mappings":"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","names":["ContractRoyalty","featureName","FEATURE_ROYALTY","name","constructor","contractWrapper","metadata","this","getDefaultRoyaltyInfo","royaltyRecipient","royaltyBps","read","CommonRoyaltySchema","parseAsync","fee_recipient","seller_fee_basis_points","getTokenRoyaltyInfo","tokenId","setDefaultRoyaltyInfo","buildTransactionFunction","async","oldMetadata","get","mergedMetadata","parseInputMetadata","royaltyData","contractURI","_parseAndUploadMetadata","hasFunction","contractEncoder","ContractEncoder","encoded","encode","Transaction","fromContractWrapper","method","args","parse","receipt","data","Error","setTokenRoyaltyInfo","parsedRoyaltyData","DelayedReveal","storage","nextTokenIdToMintFn","createDelayedRevealBatch","placeholder","metadatas","password","options","placeholderUris","uploadBatch","CommonNFTInput","rewriteFileNames","fileStartNumber","placeholderUri","getBaseUriFromBatch","startFileNumber","uris","map","m","onProgress","toNumber","baseUri","baseUriId","hashedPassword","hashDelayRevealPassword","encryptedBaseUri","utils.toUtf8Bytes","isLegacyContract","chainId","getChainID","provenanceHash","utils.solidityKeccak256","utils.defaultAbiCoder","length","endsWith","events","parseLogs","logs","startingIndex","startTokenId","endingIndex","endTokenId","results","id","lte","add","push","reveal","batchId","key","decryptedUri","callStatic","includes","e","getBatchesToReveal","count","isZero","countRangeArray","Array","from","keys","uriIndices","Promise","all","i","uriIndicesWithZeroStart","slice","tokenMetadatas","getNftMetadata","toString","legacyContract","encryptedBaseUris","getLegacyEncryptedData","utils.hexDataLength","decode","meta","index","BigNumber","batchUri","uri","placeholderMetadata","filter","_","batchTokenIndex","contractAddress","address","fetchTokenMetadataForContract","getProvider","DeprecatedAbi","__vitePreload","default","__vite_default__","import","__VITE_PRELOAD__","legacy","Contract","result","functions","calculateClaimCost","pricePerToken","quantity","currencyAddress","checkERC20Allowance","overrides","currency","NATIVE_TOKEN_ADDRESS","totalCost","normalizePriceValue","mul","gt","value","approveErc20Allowance","ContractOwner","FEATURE_OWNER","set","resolvedAddress","resolveAddress"],"ignoreList":[0],"sources":["../../node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js"],"sourcesContent":["import { h as hasFunction } from './contract-appuri-5c40af52.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { d5 as FEATURE_ROYALTY, bF as CommonRoyaltySchema, aV as NATIVE_TOKEN_ADDRESS, d6 as FEATURE_OWNER, aL as resolveAddress } from './index-33cd3415.browser.esm.js';\nimport { C as ContractEncoder } from './fetchCurrencyValue-32d08b05.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport { C as CommonNFTInput } from './setErc20Allowance-7f76f677.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, g as getBaseUriFromBatch } from './QueryParams-32a56510.browser.esm.js';\nimport { a as approveErc20Allowance } from './signature-d3ea643d.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-9851c0eb.browser.esm.js';\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns  The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const DeprecatedAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json')).default;\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns The owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\nexport { ContractRoyalty as C, DelayedReveal as D, ContractOwner as a, calculateClaimCost as c };\n"],"file":"assets/contract-owner-49e75547.browser.esm-_SCqISV8.js"}