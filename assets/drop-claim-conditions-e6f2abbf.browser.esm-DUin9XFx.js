import{t,l as a,n as e,C as r,c as i,f as s,p as o,d as n,b as c,e as l,u as p,g as h,h as m}from"./index-voFwA1yT.js";import{y as d,bo as u,E as g,aI as C,aJ as w,B as y,ac as W,aK as f,c as P,aL as D,a2 as S,J as A,T as v,t as b}from"./index-BdgVNXf3.js";import{h as N,d as x}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";class k{constructor(t,a,e){this.storage=e,this.contractWrapper=t,this.metadata=a}async getActive(a){const[e,r,i]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await t(e,i,this.contractWrapper.getProvider(),r.merkle||{},this.storage,a?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return a(t)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[e]);return a(r)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("claimCondition",[]);return e(t)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const a=void 0!==t?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),r=await this.contractWrapper.read("getClaimConditionById",[a]);return e(r)}throw new Error("Contract does not support claim conditions")}async getAll(a){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[e,r]=await this.contractWrapper.read("claimCondition",[]),i=e.toNumber(),s=r.toNumber(),o=[];for(let t=i;t<i+s;t++)o.push(this.get(t));const[n,c,...l]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...o]);return Promise.all(l.map((e=>t(e,c,this.contractWrapper.getProvider(),n.merkle,this.storage,a?.withAllowList||!1))))}return[await this.getActive(a)]}async canClaim(t,a){return a&&(a=await d(a)),0===(await this.getClaimIneligibilityReasons(t,a)).length}async getClaimIneligibilityReasons(t,a){const e=[];let s,o;if(void 0===a)try{a=await this.contractWrapper.getSignerAddress()}catch(m){}if(!a)return[r.NoWallet];const[n,c]=await Promise.all([d(a),this.getTokenDecimals()]),l=u(g.parse(t),c);try{o=await this.getActive()}catch(m){return C(m,"!CONDITION")||C(m,"no active mint condition")||C(m,"DropNoActiveCondition")?(e.push(r.NoClaimConditionSet),e):(e.push(r.Unknown),e)}if("unlimited"!==o.availableSupply){if(u(o.availableSupply,c).lt(l))return e.push(r.NotEnoughSupply),e}const p=w(o.merkleRootHash).length>0;let h=null;if(p){if(h=await this.getClaimerProofs(n),!h&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return e.push(r.AddressNotAllowed),e;if(h)try{const a=await this.prepareClaim(t,!1,c,n);let i;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(s=await this.contractWrapper.read("getActiveClaimConditionId",[]),[i]=await this.contractWrapper.read("verifyClaimMerkleProof",[s,n,t,a.proofs,a.maxClaimable]),!i)return e.push(r.AddressNotAllowed),e}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([i]=await this.contractWrapper.read("verifyClaimMerkleProof",[n,t,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable}]),!i)return e.push(r.AddressNotAllowed),e}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[n,t,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(s=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[s,n,t,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]))}catch(P){switch(P.reason||P.errorName){case"!Qty":case"DropClaimExceedLimit":e.push(r.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":case"DropClaimInvalidTokenPrice":e.push(r.WrongPriceOrCurrency);break;case"!MaxSupply":case"DropClaimExceedMaxSupply":e.push(r.NotEnoughSupply);break;case"cant claim yet":case"DropClaimNotStarted":e.push(r.ClaimPhaseNotStarted);break;default:e.push(r.AddressNotAllowed)}return e}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let t=y.from(0),a=i(o.maxClaimablePerWallet,c);try{t=await this.getSupplyClaimedByWallet(n)}catch(P){}if(h&&(a=i(h.maxClaimable,c)),a.gt(0)&&a.lt(t.add(l)))return e.push(r.OverMaxClaimablePerWallet),e;if((!p||p&&!h)&&(a.lte(t)||a.eq(0)))return e.push(r.AddressNotAllowed),e}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[t,a]=[y.from(0),y.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(s=await this.contractWrapper.read("getActiveClaimConditionId",[]),[t,a]=await this.contractWrapper.read("getClaimTimestamp",[s,n])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([t,a]=await this.contractWrapper.read("getClaimTimestamp",[n]));const i=y.from(Date.now()).div(1e3);if(t.gt(0)&&i.lt(a))return a.eq(W)?e.push(r.AlreadyClaimed):e.push(r.WaitBeforeNextClaimTransaction),e}return o.price.gt(0)&&f(),e}async getClaimerProofs(t,a){const e=(await this.get(a)).merkleRoot;if(w(e).length>0){const[a,r]=await Promise.all([this.metadata.get(),d(t)]);return await s(r,e.toString(),a.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t){const a=await d(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[a]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const t=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,a])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=P((()=>{var t=this;return async function(a){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=a;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper))if(e=!0,0===a.length)r=[{startTime:new Date(0),currencyAddress:S,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:D([0],32),snapshot:[]}];else if(a.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&r.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,a)=>t+a),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:i,sortedConditions:s}=await o(r,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),p={};i.forEach((t=>{p[t.merkleRoot]=t.snapshotUri}));const h=await t.metadata.get(),m=[];if(!n(h.merkle,p)){const a=await t.metadata.parseInputMetadata({...h,merkle:p}),e=await t.metadata._parseAndUploadMetadata(a);if(!N("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const a=new A(t.contractWrapper);m.push(a.encode("setContractURI",[e]))}}const d=t.contractWrapper,u=new A(d);if(t.isLegacySinglePhaseDrop(d)){const t=new A(d);m.push(t.encode("setClaimConditions",[c(s[0]),e]))}else if(t.isLegacyMultiPhaseDrop(d))m.push(u.encode("setClaimConditions",[s.map(c),e]));else if(t.isNewSinglePhaseDrop(d))m.push(u.encode("setClaimConditions",[l(s[0]),e]));else{if(!t.isNewMultiphaseDrop(d))throw new Error("Contract does not support claim conditions");m.push(u.encode("setClaimConditions",[s.map(l),e]))}if(N("multicall",t.contractWrapper))return v.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[m]});throw new Error("Contract does not support multicall")}})());update=P((async(t,a)=>{const e=await this.getAll(),r=await p(t,a,e);return await this.set.prepare(r)}));async getTokenDecimals(){return x(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,a){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3?arguments[3]:void 0;const[i,s]=await Promise.all([r||this.contractWrapper.getSignerAddress(),this.getActive()]);return h(i,t,s,(async()=>(await this.metadata.get()).merkle),e,this.contractWrapper,this.storage,a,this.getSnapshotFormatVersion())}async getClaimArguments(t,a,e){const r=await d(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[r,a,e.currencyAddress,e.price,e.proofs,e.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[r,a,e.currencyAddress,e.price,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable},b("")]:[r,a,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,pricePerToken:e.priceInProof,currency:e.currencyAddressInProof},b("")]}async getClaimTransaction(t,a,e){if(e?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const r=await this.prepareClaim(a,void 0===e?.checkERC20Allowance||e.checkERC20Allowance,await this.getTokenDecimals());return v.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,a,r),overrides:r.overrides})}isNewSinglePhaseDrop(t){return x(t,"ERC721ClaimConditionsV2")||x(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return x(t,"ERC721ClaimPhasesV2")||x(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return x(t,"ERC721ClaimConditionsV1")||x(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return x(t,"ERC721ClaimPhasesV1")||x(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?m.V1:m.V2}}export{k as D};
//# sourceMappingURL=drop-claim-conditions-e6f2abbf.browser.esm-DUin9XFx.js.map
