import{U as t,B as a,a2 as r,au as e,av as i,y as n,c as s,T as o,z as c,J as p,aw as l,ax as h,ay as d,az as m,aA as u,aB as g,aC as w,aD as y,aE as W,aF as f,aG as C,ac as b,i as S,aH as P,ab as T,aI as M,aJ as E,aK as A,aL as k,t as v,K as I,E as N,G as D}from"./index-BdgVNXf3.js";import{a as x}from"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import{d as R,h as B,a as L}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{F,b as q,c as O,D as V,u as z}from"./QueryParams-32a56510.browser.esm-CIeLU7Il.js";import{D as U,c as $}from"./contract-owner-49e75547.browser.esm-_SCqISV8.js";import{S as j,a as H,M as Q,t as J,l as _,n as G,C as K,c as X,f as Y,p as Z,d as tt,b as at,e as rt,u as et,g as it,h as nt}from"./index-voFwA1yT.js";import{s as st}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";class ot{constructor(t,a,r){this.storage=r,this.contractWrapper=t,this.metadata=a}async getActive(t,a){const r=await this.get(t),e=await this.metadata.get();return await J(r,0,this.contractWrapper.getProvider(),e.merkle,this.storage,a?.withAllowList||!1)}async get(t,a){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const a=await this.contractWrapper.read("claimCondition",[t]);return _(a)}if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=void 0!==a?a:await this.contractWrapper.read("getActiveClaimConditionId",[t]),e=await this.contractWrapper.read("getClaimConditionById",[t,r]);return _(e)}if(this.isNewSinglePhaseDrop(this.contractWrapper)){const a=await this.contractWrapper.read("claimCondition",[t]);return G(a)}if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=void 0!==a?a:await this.contractWrapper.read("getActiveClaimConditionId",[t]),e=await this.contractWrapper.read("getClaimConditionById",[t,r]);return G(e)}throw new Error("Contract does not support claim conditions")}async getAll(t,a){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]),e=r.currentStartId.toNumber(),i=r.count.toNumber(),n=[];for(let a=e;a<e+i;a++)n.push(await this.get(t,a));const s=await this.metadata.get();return Promise.all(n.map((t=>J(t,0,this.contractWrapper.getProvider(),s.merkle,this.storage,a?.withAllowList||!1))))}return[await this.getActive(t,a)]}async canClaim(t,a,r){return r&&(r=await n(r)),0===(await this.getClaimIneligibilityReasons(t,a,r)).length}async getClaimIneligibilityReasons(t,r,e){const i=[];let s,o;if(void 0===e)try{e=await this.contractWrapper.getSignerAddress()}catch(u){}if(!e)return[K.NoWallet];const c=await n(e);try{o=await this.getActive(t)}catch(u){return M(u,"!CONDITION")||M(u,"no active mint condition")||M(u,"DropNoActiveCondition")?(i.push(K.NoClaimConditionSet),i):(i.push(K.Unknown),i)}if("unlimited"!==o.availableSupply&&a.from(o.availableSupply).lt(r))return i.push(K.NotEnoughSupply),i;const p=E(o.merkleRootHash).length>0;let l=null;if(p){if(l=await this.getClaimerProofs(t,c),!l&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return i.push(K.AddressNotAllowed),i;if(l)try{const a=await this.prepareClaim(t,r,!1,c);let e;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(s=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[e]=await this.contractWrapper.read("verifyClaimMerkleProof",[s,c,t,r,a.proofs,a.maxClaimable]),!e)return i.push(K.AddressNotAllowed),i}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([e]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,c,r,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable}]),!e)return i.push(K.AddressNotAllowed),i}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,c,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(s=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[s,c,t,r,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]))}catch(g){switch(g.reason||g.errorName){case"!Qty":case"DropClaimExceedLimit":i.push(K.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":case"DropClaimInvalidTokenPrice":i.push(K.WrongPriceOrCurrency);break;case"!MaxSupply":case"DropClaimExceedMaxSupply":i.push(K.NotEnoughSupply);break;case"cant claim yet":case"DropClaimNotStarted":i.push(K.ClaimPhaseNotStarted);break;default:i.push(K.AddressNotAllowed)}return i}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let e=a.from(0),n=X(o.maxClaimablePerWallet,0);try{e=await this.getSupplyClaimedByWallet(t,c)}catch(g){}if(l&&(n=X(l.maxClaimable,0)),n.gt(0)&&n.lt(e.add(r)))return i.push(K.OverMaxClaimablePerWallet),i;if((!p||p&&!l)&&(n.lte(e)||n.eq(0)))return i.push(K.AddressNotAllowed),i}let[h,d]=[a.from(0),a.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(s=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[h,d]=await this.contractWrapper.read("getClaimTimestamp",[t,s,c])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([h,d]=await this.contractWrapper.read("getClaimTimestamp",[t,c]));const m=a.from(Date.now()).div(1e3);return h.gt(0)&&m.lt(d)?(d.eq(b)?i.push(K.AlreadyClaimed):i.push(K.WaitBeforeNextClaimTransaction),i):(o.price.gt(0)&&A(),i)}async getClaimerProofs(t,a,r){const e=(await this.get(t,r)).merkleRoot;if(E(e).length>0){const t=await this.metadata.get(),r=await n(a);return await Y(r,e.toString(),t.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}return null}async getSupplyClaimedByWallet(t,a){const r=await n(a);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const a=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,a,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=s((()=>{var t=this;return async function(a,r){let e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t.setBatch.prepare([{tokenId:a,claimConditions:r}],e)}})());setBatch=s((()=>{var t=this;return async function(a){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i={},n=await Promise.all(a.map((async a=>{let{tokenId:n,claimConditions:s}=a,o=s;if(t.isLegacySinglePhaseDrop(t.contractWrapper))if(e=!0,0===s.length)o=[{startTime:new Date(0),currencyAddress:r,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:k([0],32),snapshot:[]}];else if(s.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&o.forEach((t=>{if(t.snapshot&&t.snapshot.length>0&&(void 0===t.maxClaimablePerWallet||"unlimited"===t.maxClaimablePerWallet))throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");if(t.snapshot&&t.snapshot.length>0&&"0"===t.maxClaimablePerWallet?.toString()&&0===t.snapshot.map((t=>"string"==typeof t?0:Number(t.maxClaimable?.toString()||0))).reduce(((t,a)=>t+a),0))throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")}));const{snapshotInfos:c,sortedConditions:p}=await Z(o,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return c.forEach((t=>{i[t.merkleRoot]=t.snapshotUri})),{tokenId:n,sortedConditions:p}}))),s=await t.metadata.get(),c=[];for(const t of Object.keys(s.merkle||{}))i[t]=s.merkle[t];if(!tt(s.merkle,i)){const a=await t.metadata.parseInputMetadata({...s,merkle:i}),r=await t.metadata._parseAndUploadMetadata(a);if(!B("setContractURI",t.contractWrapper))throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");{const a=new p(t.contractWrapper);c.push(a.encode("setContractURI",[r]))}}if(n.forEach((a=>{let{tokenId:r,sortedConditions:i}=a;const n=new p(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const a=new p(t.contractWrapper);c.push(a.encode("setClaimConditions",[r,at(i[0]),e]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(n.encode("setClaimConditions",[r,i.map(at),e]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(n.encode("setClaimConditions",[r,rt(i[0]),e]));else{if(!t.isNewMultiphaseDrop(t.contractWrapper))throw new Error("Contract does not support claim conditions");c.push(n.encode("setClaimConditions",[r,i.map(rt),e]))}})),B("multicall",t.contractWrapper))return o.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})());update=s((async(t,a,r)=>{const e=await this.getAll(t),i=await et(a,r,e);return await this.set.prepare(t,i)}));async prepareClaim(t,a,r,e){const i=await n(e||await this.contractWrapper.getSignerAddress());return it(i,a,await this.getActive(t),(async()=>(await this.metadata.get()).merkle),0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,a,r,e){const i=await n(a);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[i,t,r,e.currencyAddress,e.price,e.proofs,e.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[i,t,r,e.currencyAddress,e.price,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable},v("")]:[i,t,r,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,pricePerToken:e.priceInProof,currency:e.currencyAddressInProof},v("")]}async getClaimTransaction(t,a,r,e){if(e?.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const i=await this.prepareClaim(a,r,e?.checkERC20Allowance||!0);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(a,t,r,i),overrides:i.overrides})}isNewSinglePhaseDrop(t){return R(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return R(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return R(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return R(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?nt.V1:nt.V2}}const ct=(()=>c.object({address:D,quantity:N.default(1)}))(),pt=(()=>c.union([c.array(c.string()).transform((async t=>await Promise.all(t.map((t=>ct.parseAsync({address:t})))))),c.array(ct)]))();class lt{featureName=w.name;constructor(t){this.contractWrapper=t}async getClaimTransaction(t,a,r,e){let i={};return e&&e.pricePerToken&&(i=await $(this.contractWrapper,e.pricePerToken,r,e.currencyAddress,e.checkERC20Allowance)),o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await n(t),a,r],overrides:i})}to=s((async(t,a,r,e)=>await this.getClaimTransaction(t,a,r,e)))}class ht{featureName=y.name;constructor(t,a){this.contractWrapper=t,this.storage=a;const r=new L(this.contractWrapper,I,this.storage);this.conditions=new ot(t,r,this.storage)}to=s((async(t,a,r,e)=>await this.conditions.getClaimTransaction(t,a,r,e)))}class dt{featureName=W.name;constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.roles=r}mint=s((async t=>{const a=t.payload,r=t.signature,[e,i]=await Promise.all([this.mapPayloadToContractStruct(a),this.contractWrapper.getCallOverrides()]);return await st(this.contractWrapper,e.pricePerToken.mul(e.quantity),a.currencyAddress,i),o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[e,r],overrides:i,parse:t=>{const a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw new Error("No MintWithSignature event found");return{id:a[0].args.tokenIdMinted,receipt:t}}})}));mintBatch=s((async t=>{const r=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),e=t.map(((t,e)=>{const i=r[e],n=t.signature,s=t.payload.price;if(a.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:i,signature:n}})),i=new p(this.contractWrapper),n=e.map((t=>i.encode("mintWithSignature",[t.message,t.signature])));if(B("multicall",this.contractWrapper))return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:t=>{const a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw new Error("No MintWithSignature event found");return a.map((a=>({id:a.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not supported on this contract!")}));async verify(t){const a=t.payload,r=t.signature,e=await this.mapPayloadToContractStruct(a);return(await this.contractWrapper.read("verify",[e,r]))[0]}async generate(t){const a={...t,tokenId:b};return this.generateFromTokenId(a)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const a=t.map((t=>({...t,tokenId:b})));return this.generateBatchFromTokenIds(a)}async generateBatchFromTokenIds(t){const a=this.contractWrapper.getSigner();S(a),await(this.roles?.verify(["minter"],await a.getAddress()));const r=await Promise.all(t.map((t=>j.parseAsync(t)))),e=r.map((t=>t.metadata)),[i,n,s]=await Promise.all([O(e,this.storage),this.contractWrapper.getChainID(),P(this.contractWrapper.address,this.contractWrapper.getProvider())]),o=await Promise.all(r.map(((t,a)=>H.parseAsync({...t,uri:i[a]})))),c=await Promise.all(o.map((t=>this.mapPayloadToContractStruct(t)))),p="TokenERC1155"===s?.type;return(await Promise.all(c.map((t=>this.contractWrapper.signTypedData(a,{name:p?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:n,verifyingContract:this.contractWrapper.address},{MintRequest:Q},t))))).map(((t,a)=>({payload:o[a],signature:t.toString()})))}async mapPayloadToContractStruct(t){const a=await T(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:a,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class mt{featureName=m.name;constructor(t){this.contractWrapper=t}tokens=s((async(t,a)=>{const r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,a)}));from=s((async(t,a,r)=>o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await n(t),a,r]})));batch=s((async(t,a)=>{const r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,a)}));batchFrom=s((async(t,a,r)=>o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await n(t),a,r]})))}class ut{featureName=l.name;constructor(t,a){this.erc1155=t,this.contractWrapper=a}async all(t){const r=a.from(t?.start||0).toNumber(),e=a.from(t?.count||V).toNumber(),i=Math.min((await this.totalCount()).toNumber(),r+e);return await Promise.all([...Array(i-r).keys()].map((t=>this.erc1155.get((r+t).toString()))))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,a){const[r,e]=await Promise.all([n(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let i=(await this.contractWrapper.read("balanceOfBatch",[Array(e.toNumber()).fill(r),Array.from(Array(e.toNumber()).keys())])).map(((t,a)=>({tokenId:a,balance:t}))).filter((t=>t.balance.gt(0)));if(a){const t=a?.start||0,r=a?.count||V;i=i.slice(t,t+r)}return(await Promise.all(i.map((t=>this.erc1155.get(t.tokenId.toString()))))).map(((t,a)=>({...t,owner:r,quantityOwned:i[a].balance.toString()})))}}class gt{featureName=u.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r,this.revealer=this.detectErc1155Revealable()}lazyMint=s((async(t,a)=>{const r=await this.erc1155.nextTokenIdToMint(),e=await O(t,this.storage,r.toNumber(),a),i=e[0].substring(0,e[0].lastIndexOf("/"));for(let o=0;o<e.length;o++){const t=e[o].substring(0,e[o].lastIndexOf("/"));if(i!==t)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${i}' but got '${t}'`)}const n=t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args.startTokenId,e=a[0].args.endTokenId,i=[];for(let n=r;n.lte(e);n=n.add(1))i.push({id:n,receipt:t,data:()=>this.erc1155.getTokenMetadata(n)});return i},s=await P(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,s)?o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,`${i.endsWith("/")?i:`${i}/`}`],parse:n}):o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,`${i.endsWith("/")?i:`${i}/`}`,v("")],parse:n})}));updateMetadata=s((async(t,r,e)=>{const i=await this.contractWrapper.read("getBaseURICount",[]);if(i.eq(0))throw new Error("No base URI set. Please set a base URI before updating metadata");const n=a.from(t);let s=a.from(0),c=a.from(0),p=0;for(let a=0;a<i.toNumber()&&(p=a,c=await this.contractWrapper.read("getBatchIdAtIndex",[p]),!c.gt(n));a++)s=c;const l=Array.from({length:c.sub(s).toNumber()},((t,a)=>a+s.toNumber())),h=await Promise.all(l.map((t=>this.erc1155.getTokenMetadata(t)))),d=[];for(let o=0;o<h.length;o++){const{id:t,uri:e,...i}=h[o];a.from(n).eq(a.from(t))?d.push(r):d.push(i)}const m=await O(d,this.storage,s.toNumber(),e),u=m[0].substring(0,m[0].lastIndexOf("/"));return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateBatchBaseURI",args:[p,`${u.endsWith("/")?u:`${u}/`}`]})}));detectErc1155Revealable(){if(R(this.contractWrapper,"ERC1155Revealable"))return new U(this.contractWrapper,this.storage,f.name,(()=>this.erc1155.nextTokenIdToMint()))}isLegacyEditionDropContract(t,a){return a&&"DropERC1155"===a.type&&a.version<3||!1}}class wt{featureName=d.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r}to=s((async(t,a)=>{const r=a.map((t=>t.metadata)),e=a.map((t=>t.supply)),i=await O(r,this.storage),s=await n(t),c=new p(this.contractWrapper),l=await Promise.all(i.map((async(t,a)=>c.encode("mintTo",[s,b,t,e[a]]))));return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[l],parse:t=>{const a=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===a.length||a.length<r.length)throw new Error("TokenMinted event not found, minting failed");return a.map((a=>{const r=a.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc1155.get(r)}}))}})}))}class yt{featureName=h.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r,this.batch=this.detectErc1155BatchMintable()}to=s((async(t,a)=>{const r=await this.getMintTransaction(t,a);return r.setParse((t=>{const a=this.contractWrapper.parseLogs("TransferSingle",t?.logs);if(0===a.length)throw new Error("TransferSingleEvent event not found");const r=a[0].args.id;return{id:r,receipt:t,data:()=>this.erc1155.get(r.toString())}})),r}));async getMintTransaction(t,a){const r=await z(a.metadata,this.storage);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await n(t),b,r,a.supply]})}additionalSupplyTo=s((async(t,r,e)=>{const i=await this.erc1155.getTokenMetadata(r);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await n(t),r,i.uri,e],parse:t=>({id:a.from(r),receipt:t,data:()=>this.erc1155.get(r)})})}));detectErc1155BatchMintable(){if(R(this.contractWrapper,"ERC1155BatchMintable"))return new wt(this.erc1155,this.contractWrapper,this.storage)}}class Wt{featureName=t.name;get chainId(){return this._chainId}constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[e,i]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch((()=>a.from(0))),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...F})))]);return{owner:r,metadata:i,type:"ERC1155",supply:e.toString()}}async totalSupply(t){if(R(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new e(i)}async balanceOf(t,a){return await this.contractWrapper.read("balanceOf",[await n(t),a])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,a){return await this.contractWrapper.read("isApprovedForAll",[await n(t),await n(a)])}transfer=s((()=>{var t=this;return async function(a,r,e){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const s=await t.contractWrapper.getSignerAddress();return o.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[s,await n(a),r,e,i]})}})());transferBatch=s((()=>{var t=this;return async function(a,r,e,i){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[0];const c=i?await n(i):await t.contractWrapper.getSignerAddress();return o.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeBatchTransferFrom",args:[c,await n(a),r,e,s]})}})());transferFrom=s((()=>{var t=this;return async function(a,r,e,i){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[0];return o.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await n(a),await n(r),e,i,s]})}})());setApprovalForAll=s((async(t,a)=>o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,a]})));airdrop=s((()=>{var t=this;return async function(r,e,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0];const c=i?await n(i):await t.contractWrapper.getSignerAddress(),l=await t.balanceOf(c,r),h=await pt.parseAsync(e),d=h.reduce(((t,r)=>a.from(t).add(a.from(r?.quantity||1))),a.from(0));if(l.lt(a.from(d)))throw new Error(`The caller owns ${l.toString()} NFTs, but wants to airdrop ${d.toString()} NFTs.`);const m=new p(t.contractWrapper),u=h.map((t=>{let{address:a,quantity:e}=t;return m.encode("safeTransferFrom",[c,a,r,e,s])}));return o.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[u]})}})());async nextTokenIdToMint(){if(B("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return x(this.query,l).all(t)}async totalCount(){return x(this.query,l).totalCount()}async totalCirculatingSupply(t){return x(this.query,l).totalCirculatingSupply(t)}async getOwned(t,a){return t&&(t=await n(t)),x(this.query,l).owned(t,a)}mint=s((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=s((async(t,a)=>x(this.mintable,h).to.prepare(t,a)));async getMintTransaction(t,a){return x(this.mintable,h).getMintTransaction(t,a)}mintAdditionalSupply=s((async(t,a)=>x(this.mintable,h).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,a)));mintAdditionalSupplyTo=s((async(t,a,r)=>x(this.mintable,h).additionalSupplyTo.prepare(t,a,r)));mintBatch=s((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=s((async(t,a)=>x(this.mintable?.batch,d).to.prepare(t,a)));burn=s((async(t,a)=>x(this.burnable,m).tokens.prepare(t,a)));burnFrom=s((async(t,a,r)=>x(this.burnable,m).from.prepare(t,a,r)));burnBatch=s((async(t,a)=>x(this.burnable,m).batch.prepare(t,a)));burnBatchFrom=s((async(t,a,r)=>x(this.burnable,m).batchFrom.prepare(t,a,r)));lazyMint=s((async(t,a)=>x(this.lazyMintable,u).lazyMint.prepare(t,a)));updateMetadata=s((async(t,a)=>{if(this.lazyMintable)return this.lazyMintable.updateMetadata.prepare(t,a);if(R(this.contractWrapper,"ERC1155UpdatableMetadata")){const r=await this.storage.upload(a);return o.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,r]})}throw new e(g)}));async getClaimTransaction(t,a,r,i){const n=this.claimWithConditions,s=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,a,r,i);if(s)return s.getClaimTransaction(t,a,r,i);throw new e(w)}claim=s((async(t,a,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,a,r)));claimTo=s((async(t,a,r,i)=>{const n=this.claimWithConditions,s=this.claimCustom;if(n)return n.to.prepare(t,a,r,i);if(s)return s.to.prepare(t,a,r,i);throw new e(w)}));get claimConditions(){return x(this.claimWithConditions,y).conditions}get signature(){return x(this.signatureMintable,W)}get revealer(){return x(this.lazyMintable?.revealer,f)}async getTokenMetadata(t){const a=await this.contractWrapper.read("uri",[t]);if(!a)throw new C;return q(t,a,this.storage)}detectErc1155Enumerable(){if(R(this.contractWrapper,"ERC1155Enumerable"))return new ut(this,this.contractWrapper)}detectErc1155Mintable(){if(R(this.contractWrapper,"ERC1155Mintable"))return new yt(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if(R(this.contractWrapper,"ERC1155Burnable"))return new mt(this.contractWrapper)}detectErc1155LazyMintable(){if(R(this.contractWrapper,"ERC1155LazyMintableV1")||R(this.contractWrapper,"ERC1155LazyMintableV2"))return new gt(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if(R(this.contractWrapper,"ERC1155SignatureMintable"))return new dt(this.contractWrapper,this.storage)}detectErc1155Claimable(){if(R(this.contractWrapper,"ERC1155ClaimCustom"))return new lt(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if(R(this.contractWrapper,"ERC1155ClaimConditionsV1")||R(this.contractWrapper,"ERC1155ClaimConditionsV2")||R(this.contractWrapper,"ERC1155ClaimPhasesV1")||R(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new ht(this.contractWrapper,this.storage)}}export{ot as D,Wt as E,dt as a};
//# sourceMappingURL=erc-1155-7ce9bee1.browser.esm-BSstTiNG.js.map
