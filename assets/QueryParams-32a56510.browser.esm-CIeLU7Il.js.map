{"version":3,"mappings":"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","names":["InterfaceId_IERC721","utils.arrayify","InterfaceId_IERC1155","FALLBACK_METADATA","name","async","fetchTokenMetadata","tokenId","tokenUri","storage","startsWith","Buffer","base64","split","jsonMetadata","JSON","parse","from","toString","CommonNFTOutput","id","BigNumber","uri","parsedUri","replace","utils.hexZeroPad","toHexString","slice","downloadJSON","err","unparsedTokenIdUri","e","fetchTokenMetadataForContract","contractAddress","provider","ERC165MetadataAbi","import","default","__vite_default__","__VITE_PRELOAD__","erc165","Contract","isERC721","isERC1155","Promise","all","supportsInterface","ERC721MetadataAbi","__vitePreload","then","n","dX","erc721","tokenURI","Error","ERC1155MetadataAbi","dZ","erc1155","uploadOrExtractURI","metadata","upload","CommonNFTInput","uploadOrExtractURIs","metadatas","startNumber","options","undefined","find","m","isUriList","isMetadataList","uploadBatch","map","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","uris","baseUri","substring","lastIndexOf","i","length","DEFAULT_QUERY_ALL_COUNT"],"ignoreList":[0],"sources":["../../node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js"],"sourcesContent":["import { a as CommonNFTOutput, C as CommonNFTInput } from './setErc20Allowance-7f76f677.browser.esm.js';\nimport { utils, BigNumber, Contract } from 'ethers';\nimport 'zod';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */(() => utils.arrayify(\"0x80ac58cd\"))();\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */(() => utils.arrayify(\"0xd9b67a26\"))();\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress - the contract address\n * @param provider - the provider to use\n * @param tokenId - the token id\n * @param storage - the storage to use\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const ERC165MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new Contract(contractAddress, ERC165MetadataAbi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const ERC721MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json')).default;\n    const erc721 = new Contract(contractAddress, ERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const ERC1155MetadataAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json')).default;\n    const erc1155 = new Contract(contractAddress, ERC1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata - the metadata to upload\n * @param storage - the storage to use\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas - the metadata to upload\n * @param storage - the storage to use\n * @param startNumber - the number to start the file names at\n * @param contractAddress - the contract address\n * @param signerAddress - the signer address\n * @param options - options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * @internal\n */\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Pagination Parameters\n * @public\n */\n\nexport { DEFAULT_QUERY_ALL_COUNT as D, FALLBACK_METADATA as F, InterfaceId_IERC721 as I, InterfaceId_IERC1155 as a, uploadOrExtractURI as b, fetchTokenMetadataForContract as c, fetchTokenMetadata as f, getBaseUriFromBatch as g, uploadOrExtractURIs as u };\n"],"file":"assets/QueryParams-32a56510.browser.esm-CIeLU7Il.js"}