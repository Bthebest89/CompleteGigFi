{"version":3,"file":"alchemy-websocket-provider-1e035581-ChiDRnTp.js","sources":["../../node_modules/sturdy-websocket/dist/index.js","../../node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-1e035581.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-0a90ef81.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-6749bff8.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-1e035581.js.map\n"],"names":["Object","defineProperty","dist","value","SturdyWebSocket","url","protocolsOrOptions","options","this","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","Array","isArray","protocols","result","keys","DEFAULT_OPTIONS","forEach","key","applyDefaultOptions","wsConstructor","WebSocket","Error","openNewWebSocket","prototype","get","binaryTypeInternal","set","binaryType","ws","enumerable","configurable","sum","bufferedAmount","hasUnknownAmount","data","byteLength","length","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","protocol","close","code","reason","disposeSocket","shutdown","send","readyState","push","reconnect","handleClose","addEventListener","type","listener","dispatchEvent","event","dispatchEventOfType","removeEventListener","filter","l","_this","_a","connectTimeout","handleError","handleMessage","handleOpen","connectTimeoutId","setTimeout","clearConnectTimeout","allClearResetTime","message","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","then","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","Math","max","min","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","Number","POSITIVE_INFINITY","_default","default","WebsocketBackfiller","constructor","provider","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","__awaiter","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","lastSeenBlockNumber","fromHex","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","map","assign","removed","fromBlockInclusive","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","method","params","toHex","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupe","items","getKey","keysSeen","Set","item","has","add","CANCELLED","AlchemyWebSocketProvider","WebSocketProvider","config","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","VERSION","super","process","versions","node","require","w3cwebsocket","EthersNetwork","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","JSON","parse","jsonrpc","undefined","id","isResponse","isSubscriptionEvent","physicalId","subscription","virtualId","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","emitEvent","handleReopen","clear","cancel","cancelled","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","error","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","getNetwork","CustomNetworks","on","eventName","_addEventListener","once","off","isAlchemyEvent","_off","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","_listeners","verifyAlchemyEventName","EthersEvent","getAlchemyEventTag","_startEvent","ALCHEMY_EVENT_TYPES","includes","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","subId","resolvedParams","sentEvents","_subs","emit","args","stopped","eventTag","apply","_stopEvent","parts","nextId","payload","sendBatchConcurrently","destroy","removeSocketListeners","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","e","_websocket","backfillEvents","withBackoffRetries","withTimeout","events","dedupeNewHeads","emitNewHeadsEvent","dedupeLogs","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","setInterval","req","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","fromAddress","toAddress","hashesOnly","AlchemySubscription","PENDING_TRANSACTIONS","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","BigNumber","from","toNumber","_emitted","block","formatter","filterLog","found","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","f","retryCount","shouldRetry","nextWaitTime","delay","ms","resolve","promise","race","_","reject","currentBlockNumber","firstGoodIndex","findIndex","splice"],"mappings":"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","x_google_ignoreList":[0,1]}