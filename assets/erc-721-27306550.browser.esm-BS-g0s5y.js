import{S as t,a2 as a,y as r,c as e,T as n,aO as s,B as i,aP as o,aQ as c,aR as p,aS as d,aT as h,aU as l,au as u,aV as m,aW as g,aX as y,aY as W,ao as w,aZ as f,aG as T,J as C,i as b,ab as S,t as E,a_ as M,a$ as k,K as I,b0 as v,b1 as P,b2 as R,b3 as N,b4 as A,b5 as L,G as B,z as O,w as D,E as q}from"./index-BdgVNXf3.js";import{a as x}from"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import{h as z,d as U,a as F}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{F as $,b as j,c as V,D as Z,u as _,g as J}from"./QueryParams-32a56510.browser.esm-CIeLU7Il.js";import{D as G}from"./drop-claim-conditions-e6f2abbf.browser.esm-DUin9XFx.js";import{D as Q,c as H}from"./contract-owner-49e75547.browser.esm-_SCqISV8.js";import{s as K,C as X,B as Y}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import{i as tt,j as at,k as rt,m as et,B as nt}from"./index-voFwA1yT.js";class st{featureName=p.name;constructor(t){this.contractWrapper=t}token=e((async t=>n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]})))}class it{featureName=g.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r;const e=new F(this.contractWrapper,I,this.storage);this.conditions=new G(this.contractWrapper,e,this.storage)}to=e((async(t,a,r)=>{const e=await this.conditions.getClaimTransaction(t,a,r);return e.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,e=r.add(a),n=[];for(let a=r;a.lt(e);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n})),e}))}class ot{featureName=v.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}to=e((async(t,a,r)=>{if(t!==await(this.contractWrapper.getSigner()?.getAddress()))throw new Error("Zora Drop: Destination address must match connected wallet address");if(r?.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const e=(await this.getSaleDetails()).publicSalePrice,s=(o="0.000777",D(q.parse(o)));var o;const c=i.from(e).add(s).mul(a),p=n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[a],overrides:{value:c}});return p.setParse((t=>{const r=this.contractWrapper.parseLogs("Sale",t?.logs)[0].args.firstPurchasedTokenId,e=r.add(a),n=[];for(let a=r;a.lt(e);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n})),p}));async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class ct{featureName=m.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async getClaimTransaction(t,a,r){let e={};return r&&r.pricePerToken&&(e=await H(this.contractWrapper,r.pricePerToken,a,r.currencyAddress,r.checkERC20Allowance)),n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,a],overrides:e})}to=e((async(t,a,r)=>{const e=await this.getClaimTransaction(t,a,r);return e.setParse((t=>{const r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs)[0].args.startTokenId,e=r.add(a),n=[];for(let a=r;a.lt(e);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n})),e}))}class pt{featureName=h.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r,this.revealer=this.detectErc721Revealable()}lazyMint=e((async(t,a)=>{const r=await this.erc721.nextTokenIdToMint(),e=await V(t,this.storage,r.toNumber(),a),s=J(e);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,s.endsWith("/")?s:`${s}/`,E("")],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args.startTokenId,e=a[0].args.endTokenId,n=[];for(let s=r;s.lte(e);s=s.add(1))n.push({id:s,receipt:t,data:()=>this.erc721.getTokenMetadata(s)});return n}})}));updateMetadata=e((async(t,a,r)=>{const e=await this.contractWrapper.read("getBaseURICount",[]);if(e.eq(0))throw new Error("No base URI set. Please set a base URI before updating metadata");const s=i.from(t);let o=i.from(0),c=i.from(0),p=0;for(let n=0;n<e.toNumber()&&(p=n,c=await this.contractWrapper.read("getBatchIdAtIndex",[p]),!c.gt(s));n++)o=c;const d=Array.from({length:c.sub(o).toNumber()},((t,a)=>a+o.toNumber())),h=await Promise.all(d.map((t=>this.erc721.getTokenMetadata(t)))),l=[];for(let n=0;n<h.length;n++){const{id:t,uri:r,...e}=h[n];i.from(s).eq(i.from(t))?l.push(a):l.push(e)}const u=await V(l,this.storage,o.toNumber(),r),m=u[0].substring(0,u[0].lastIndexOf("/"));return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateBatchBaseURI",args:[p,`${m.endsWith("/")?m:`${m}/`}`]})}));detectErc721Revealable(){if(U(this.contractWrapper,"ERC721Revealable"))return new Q(this.contractWrapper,this.storage,w.name,(()=>this.erc721.nextTokenIdToMint()))}}class dt{featureName=d.name;constructor(t){this.contractWrapper=t}cancel=e((async t=>n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]})));revoke=e((async t=>n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]})))}class ht{featureName=l.name;constructor(t,a){this.contractWrapper=t,this.storage=a}update=e((async(t,a)=>{const r=await _(a,this.storage);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,r]})}))}class lt{featureName=c.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r}to=e((async(t,a)=>{const[e,s]=await Promise.all([V(a,this.storage),r(t)]),i=new C(this.contractWrapper),o=e.map((t=>i.encode("mintTo",[s,t])));return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[o],parse:t=>{const r=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===r.length||r.length<a.length)throw new Error("TokenMinted event not found, minting failed");return r.map((a=>{const r=a.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}))}})}))}class ut{featureName=o.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r,this.batch=this.detectErc721BatchMintable()}to=e((async(t,a)=>{const[e,s]=await Promise.all([_(a,this.storage),r(t)]);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[s,e],parse:t=>{const a=this.contractWrapper.parseLogs("Transfer",t?.logs);if(0===a.length)throw new Error("TransferEvent event not found");const r=a[0].args.tokenId;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}})}));async getMintTransaction(t,a){return this.to.prepare(await r(t),a)}detectErc721BatchMintable(){if(U(this.contractWrapper,"ERC721BatchMintable"))return new lt(this.erc721,this.contractWrapper,this.storage)}}class mt{featureName=f.name;constructor(t,a){this.contractWrapper=t,this.storage=a}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every((t=>""===t)))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}set=e((async t=>{const a=Y.parse(t);a.description=this.sanitizeJSONString(a.description);const r=[];P(a.image)?r.push(this.storage.upload(a.image)):"string"==typeof a.image?r.push(Promise.resolve(a.image)):r.push(Promise.resolve(void 0)),P(a.animation_url)?r.push(this.storage.upload(a.animation_url)):"string"==typeof a.animation_url?r.push(Promise.resolve(a.animation_url)):r.push(Promise.resolve(void 0));const[e,s]=await Promise.all(r);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${a.name||""}`,description:a.description||"",imageURI:e||"",animationURI:s||""}]})}));sanitizeJSONString(t){if(!t)return t;const a=JSON.stringify(t);return a.slice(1,a.length-1)}}class gt{featureName=R.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async all(t,a){let r=await this.tokenIds(t);if(a){const t=a?.start||0,e=a?.count||Z;r=r.slice(t,t+e)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const a=await r(t||await this.contractWrapper.getSignerAddress()),e=await this.contractWrapper.read("balanceOf",[a]),n=Array.from(Array(e.toNumber()).keys());return await Promise.all(n.map((t=>this.contractWrapper.read("tokenOfOwnerByIndex",[a,t]))))}}class yt{featureName=N.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async all(t,a){let r=await this.tokenIds(t);if(a){const t=a?.start||0,e=a?.count||Z;r=r.slice(t,t+e)}return await Promise.all(r.map((t=>this.erc721.get(t.toString()))))}async tokenIds(t){const a=await r(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[a])}}class Wt{featureName=s.name;constructor(t,a){this.erc721=t,this.contractWrapper=a,this.owned=this.detectErc721Owned()}async all(t){let a=i.from(0);z("startTokenId",this.contractWrapper)&&(a=await this.contractWrapper.read("startTokenId",[]));const r=i.from(t?.start||0).add(a).toNumber(),e=i.from(t?.count||Z).toNumber(),n=await this.erc721.nextTokenIdToMint(),s=Math.min(n.add(a).toNumber(),r+e);return await Promise.all([...Array(s-r).keys()].map((t=>this.erc721.get((r+t).toString()))))}async allOwners(t){let r,e=i.from(0);z("startTokenId",this.contractWrapper)&&(e=await this.contractWrapper.read("startTokenId",[]));try{r=await this.erc721.totalClaimedSupply()}catch(o){r=await this.totalCount()}r=r.add(e);let n=[...new Array(r.toNumber()).keys()];if(t){const a=t?.start||0,r=t?.count||Z;n=n.slice(a,a+r)}const s=await Promise.all(n.map((t=>this.erc721.ownerOf(t).catch((()=>a)))));return n.map((t=>({tokenId:t,owner:s[t]}))).filter((t=>t.owner!==a))}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){return U(this.contractWrapper,"ERC721Enumerable")?new gt(this.erc721,this.contractWrapper):U(this.contractWrapper,"ERC721AQueryable")?new yt(this.erc721,this.contractWrapper):void 0}}const wt=(()=>nt.extend({tierPriority:O.array(O.string()),royaltyRecipient:B.default(a),royaltyBps:L.default(0),quantity:A.default(1)}))(),ft=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class Tt{featureName=y.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r}async getMetadataInTier(t){const a=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find((a=>a.tier===t));if(!a)throw new Error("Tier not found in contract.");return await Promise.all(a.ranges.map(((t,r)=>{const e=[],n=a.baseURIs[r];for(let a=t.startIdInclusive.toNumber();a<t.endIdNonInclusive.toNumber();a++){const t=n.endsWith("/")?`${n}${a}`:`${n}/${a}`,r=this.storage.downloadJSON(t);e.push(r)}return e})).flat())}async getTokensInTier(t){const a=await this.contractWrapper.read("getTokensInTierLen",[]);if(a.eq(0))return[];const r=await this.contractWrapper.read("getTokensInTier",[t,0,a]);return await Promise.all(r.map((t=>{const a=[];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++)a.push(this.erc721.get(r));return a})).flat())}createBatchWithTier=e((async(t,a,r)=>{const e=await this.erc721.nextTokenIdToMint(),s=await V(t,this.storage,e.toNumber(),r),i=J(s);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[s.length,i.endsWith("/")?i:`${i}/`,a,E("")],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args[1],e=a[0].args[2],n=[];for(let s=r;s.lte(e);s=s.add(1))n.push({id:s,receipt:t,data:()=>this.erc721.getTokenMetadata(s)});return n}})}));createDelayedRevealBatchWithTier=e((async(t,a,r,e,s)=>{if(!r)throw new Error("Password is required");const i=await this.storage.uploadBatch([X.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),o=J(i),c=await this.erc721.nextTokenIdToMint(),p=await this.storage.uploadBatch(a.map((t=>X.parse(t))),{onProgress:s?.onProgress,rewriteFileNames:{fileStartNumber:c.toNumber()}}),d=J(p),h=await this.contractWrapper.read("getBaseURICount",[]),l=await this.contractWrapper.getChainID(),u=M(["string","uint256","uint256","address"],[r,l,h,this.contractWrapper.address]),m=await this.contractWrapper.read("encryptDecrypt",[E(d),u]),g=M(["bytes","bytes","uint256"],[E(d),u,l]),y=k.encode(["bytes","bytes32"],[m,g]);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[p.length,o.endsWith("/")?o:`${o}/`,e,y],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args[1],e=a[0].args[2],n=[];for(let s=r;s.lte(e);s=s.add(1))n.push({id:s,receipt:t,data:()=>this.erc721.getTokenMetadata(s)});return n}})}));reveal=e((async(t,a)=>{if(!a)throw new Error("Password is required");const r=await this.contractWrapper.getChainID(),e=M(["string","uint256","uint256","address"],[a,r,t,this.contractWrapper.address]);try{const a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw new Error("invalid password")}catch(s){throw new Error("invalid password")}return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}));async generate(t){const[a]=await this.generateBatch([t]);return a}async generateBatch(t){const a=await Promise.all(t.map((t=>wt.parseAsync(t)))),r=await this.contractWrapper.getChainID(),e=this.contractWrapper.getSigner();return b(e),await Promise.all(a.map((async t=>({payload:t,signature:(await this.contractWrapper.signTypedData(e,{name:"SignatureAction",version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{GenericRequest:ft},await this.mapPayloadToContractStruct(t))).toString()}))))}async verify(t){const a=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[a,t.signature]))[0]}async claimWithSignature(t){const a=await this.mapPayloadToContractStruct(t.payload),r=await S(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),e=await this.contractWrapper.getCallOverrides();await K(this.contractWrapper,r,t.payload.currencyAddress,e);const n=await this.contractWrapper.sendTransaction("claimWithSignature",[a,t.signature],e),s=this.contractWrapper.parseLogs("TokensClaimed",n?.logs),i=s[0].args.startTokenId,o=i.add(s[0].args.quantityClaimed),c=[];for(let p=i;p.lt(o);p=p.add(1))c.push({id:p,receipt:n,data:()=>this.erc721.get(p)});return c}async mapPayloadToContractStruct(t){const a=await S(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=k.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,a,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:r}}}class Ct{featureName=W.name;constructor(t,a){this.contractWrapper=t,this.storage=a}mint=e((async t=>{const a=t.payload,r=t.signature,e=await this.contractWrapper.getCallOverrides(),s=t=>{const a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw new Error("No MintWithSignature event found");return{id:a[0].args.tokenIdMinted,receipt:t}};if(await this.isLegacyNFTContract()){const t=await this.mapLegacyPayloadToContractStruct(a),i=t.price;return await K(this.contractWrapper,i,a.currencyAddress,e),n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:e,parse:s})}{const t=await this.mapPayloadToContractStruct(a),i=t.pricePerToken.mul(t.quantity);return await K(this.contractWrapper,i,a.currencyAddress,e),n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:e,parse:s})}}));mintBatch=e((async t=>{const a=await this.isLegacyNFTContract(),r=(await Promise.all(t.map((t=>a?this.mapLegacyPayloadToContractStruct(t.payload):this.mapPayloadToContractStruct(t.payload))))).map(((a,r)=>{const e=t[r],n=e.signature,s=e.payload.price;if(i.from(s).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:a,signature:n}})),e=new C(this.contractWrapper),s=r.map((t=>e.encode("mintWithSignature",[t.message,t.signature])));if(z("multicall",this.contractWrapper))return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:t=>{const a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw new Error("No MintWithSignature event found");return a.map((a=>({id:a.args.tokenIdMinted,receipt:t})))}});throw new Error("Multicall not available on this contract!")}));async verify(t){const a=await this.isLegacyNFTContract(),r=t.payload,e=t.signature;let n,s;return a?(n=await this.mapLegacyPayloadToContractStruct(r),s=await this.contractWrapper.read("verify",[n,e])):(n=await this.mapPayloadToContractStruct(r),s=await this.contractWrapper.read("verify",[n,e])),s[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const a=await this.isLegacyNFTContract(),r=await Promise.all(t.map((t=>tt.parseAsync(t)))),e=r.map((t=>t.metadata)),n=await V(e,this.storage),s=await this.contractWrapper.getChainID(),i=this.contractWrapper.getSigner();return b(i),await Promise.all(r.map((async(t,r)=>{const e=n[r],o=await at.parseAsync({...t,uri:e});let c;return c=a?await this.contractWrapper.signTypedData(i,{name:"TokenERC721",version:"1",chainId:s,verifyingContract:this.contractWrapper.address},{MintRequest:rt},await this.mapLegacyPayloadToContractStruct(o)):await this.contractWrapper.signTypedData(i,{name:"SignatureMintERC721",version:"1",chainId:s,verifyingContract:await this.contractWrapper.address},{MintRequest:et},await this.mapPayloadToContractStruct(o)),{payload:o,signature:c.toString()}})))}async mapPayloadToContractStruct(t){const a=await S(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:a,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const a=await S(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:a,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return U(this.contractWrapper,"ERC721SignatureMintV1")}}class bt{featureName=t.name;get chainId(){return this._chainId}constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[r,e]=await Promise.all([this.ownerOf(t).catch((()=>a)),this.getTokenMetadata(t).catch((()=>({id:t.toString(),uri:"",...$})))]);return{owner:r,metadata:e,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await r(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,a){const[e,n]=await Promise.all([r(t),r(a)]);return await this.contractWrapper.read("isApprovedForAll",[e,n])}transfer=e((async(t,a)=>{const[e,s]=await Promise.all([this.contractWrapper.getSignerAddress(),r(t)]);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[e,s,a]})}));transferFrom=e((async(t,a,e)=>{const[s,i]=await Promise.all([r(t),r(a)]);return n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[s,i,e]})}));setApprovalForAll=e((async(t,a)=>n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await r(t),a]})));setApprovalForToken=e((async(t,a)=>n.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await r(t),a]})));async getAll(t){return x(this.query,s).all(t)}async getAllOwners(t){return x(this.query,s).allOwners(t)}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return x(this.query,s).totalCirculatingSupply()}async getOwned(t,a){if(t&&(t=await r(t)),this.query?.owned)return this.query.owned.all(t,a);{const[r,e]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners(a)]),n=(e||[]).filter((t=>r?.toLowerCase()===t.owner?.toLowerCase()));return await Promise.all(n.map((async t=>this.get(t.tokenId))))}}async getOwnedTokenIds(t){if(t&&(t=await r(t)),this.query?.owned)return this.query.owned.tokenIds(t);{const[a,r]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(r||[]).filter((t=>a?.toLowerCase()===t.owner?.toLowerCase())).map((t=>i.from(t.tokenId)))}}mint=e((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=e((async(t,a)=>x(this.mintable,o).to.prepare(t,a)));async getMintTransaction(t,a){return this.mintTo.prepare(t,a)}mintBatch=e((async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintBatchTo=e((async(t,a)=>x(this.mintable?.batch,c).to.prepare(t,a)));burn=e((async t=>x(this.burnable,p).token.prepare(t)));cancel=e((async t=>x(this.loyaltyCard,d).cancel.prepare(t)));revoke=e((async t=>x(this.loyaltyCard,d).revoke.prepare(t)));lazyMint=e((async(t,a)=>x(this.lazyMintable,h).lazyMint.prepare(t,a)));updateMetadata=e((async(t,a)=>this.lazyMintable?this.lazyMintable.updateMetadata.prepare(t,a):x(this.updatableMetadata,l).update.prepare(t,a)));async update(t,a){return this.updateMetadata(t,a)}claim=e((async(t,a)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,a)));claimTo=e((async(t,a,r)=>{const e=this.claimWithConditions,n=this.claimCustom,s=this.claimZora;if(e)return e.to.prepare(t,a,r);if(n)return n.to.prepare(t,a,r);if(s)return s.to.prepare(t,a,r);throw new u(m)}));async getClaimTransaction(t,a,r){const e=this.claimWithConditions,n=this.claimCustom;if(e)return e.conditions.getClaimTransaction(t,a,r);if(n)return n.getClaimTransaction(t,a,r);throw new u(m)}async totalClaimedSupply(){const t=this.contractWrapper;if(z("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if(z("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,a]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(a)}get claimConditions(){return x(this.claimWithConditions,g).conditions}get tieredDrop(){return x(this.tieredDropable,y)}get signature(){return x(this.signatureMintable,W)}get revealer(){return x(this.lazyMintable?.revealer,w)}get sharedMetadata(){return x(this.erc721SharedMetadata,f)}async getTokenMetadata(t){const a=await this.contractWrapper.read("tokenURI",[t]);if(!a)throw new T;return j(t,a,this.storage)}async nextTokenIdToMint(){if(z("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return z("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}if(z("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if(U(this.contractWrapper,"ERC721Supply")||z("nextTokenIdToMint",this.contractWrapper))return new Wt(this,this.contractWrapper)}detectErc721Mintable(){if(U(this.contractWrapper,"ERC721Mintable"))return new ut(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if(U(this.contractWrapper,"ERC721Burnable"))return new st(this.contractWrapper)}detectErc721LazyMintable(){if(U(this.contractWrapper,"ERC721LazyMintable"))return new pt(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if(U(this.contractWrapper,"ERC721TieredDrop"))return new Tt(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if(U(this.contractWrapper,"ERC721SignatureMintV1")||U(this.contractWrapper,"ERC721SignatureMintV2"))return new Ct(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if(U(this.contractWrapper,"ERC721ClaimConditionsV1")||U(this.contractWrapper,"ERC721ClaimConditionsV2")||U(this.contractWrapper,"ERC721ClaimPhasesV1")||U(this.contractWrapper,"ERC721ClaimPhasesV2"))return new it(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if(U(this.contractWrapper,"ERC721ClaimCustom"))return new ct(this,this.contractWrapper)}detectErc721ClaimableZora(){if(U(this.contractWrapper,"ERC721ClaimZora"))return new ot(this,this.contractWrapper)}detectErc721SharedMetadata(){if(U(this.contractWrapper,"ERC721SharedMetadata"))return new mt(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if(U(this.contractWrapper,"ERC721LoyaltyCard"))return new dt(this.contractWrapper)}detectErc721UpdatableMetadata(){if(U(this.contractWrapper,"ERC721UpdatableMetadata"))return new ht(this.contractWrapper,this.storage)}}export{bt as E,Ct as a};
//# sourceMappingURL=erc-721-27306550.browser.esm-BS-g0s5y.js.map
