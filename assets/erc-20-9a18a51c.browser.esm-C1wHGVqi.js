import{R as t,ae as r,y as a,c as e,T as s,J as n,bj as i,bk as c,bl as o,bm as p,bn as m,ad as h,B as l,i as d,ab as u,bo as W,E as g,K as w}from"./index-BdgVNXf3.js";import{a as y}from"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import{d as f,a as b}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{D as C}from"./drop-claim-conditions-e6f2abbf.browser.esm-DUin9XFx.js";import{s as P}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import{q as A,s as E,v as S}from"./index-voFwA1yT.js";class T{featureName=o.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}tokens=e((async t=>s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})));from=e((async(t,r)=>s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([a(t),this.erc20.normalizeAmount(r)])})))}class v{featureName=p.name;constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a;const e=new b(this.contractWrapper,w,this.storage);this.conditions=new C(this.contractWrapper,e,this.storage)}to=e((async(t,r,a)=>{const e=await this.erc20.normalizeAmount(r);return await this.conditions.getClaimTransaction(t,e,a)}))}class M{constructor(t,r,a){this.erc20=t,this.contractWrapper=r,this.storage=a,this.claim=new v(this.erc20,this.contractWrapper,this.storage)}}class B{featureName=c.name;constructor(t,r){this.erc20=t,this.contractWrapper=r}to=e((async t=>{const r=new n(this.contractWrapper),e=(await Promise.all(t.map((t=>Promise.all([a(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[a,e]=t;return r.encode("mintTo",[a,e])}));return s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})}))}class R{featureName=i.name;constructor(t,r){this.erc20=t,this.contractWrapper=r,this.batch=this.detectErc20BatchMintable()}to=e((async(t,r)=>await this.getMintTransaction(t,r)));async getMintTransaction(t,r){return s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([a(t),this.erc20.normalizeAmount(r)])})}detectErc20BatchMintable(){if(f(this.contractWrapper,"ERC20BatchMintable"))return new B(this.erc20,this.contractWrapper)}}class z{featureName=m.name;constructor(t,r){this.contractWrapper=t,this.roles=r}mint=e((async t=>{const r=t.payload,a=t.signature,[e,n]=await Promise.all([this.mapPayloadToContractStruct(r),this.contractWrapper.getCallOverrides()]);return await P(this.contractWrapper,l.from(e.price),r.currencyAddress,n),s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[e,a],overrides:n})}));mintBatch=e((async t=>{const r=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),a=t.map(((t,a)=>{const e=r[a],s=t.signature,n=t.payload.price;if(l.from(n).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:e,signature:s}})),e=new n(this.contractWrapper),i=a.map((t=>e.encode("mintWithSignature",[t.message,t.signature])));return s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i]})}));async verify(t){const r=t.payload,a=t.signature,e=await this.mapPayloadToContractStruct(r);return(await this.contractWrapper.read("verify",[e,a]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await(this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[r,a,e]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>A.parseAsync(t))))]),s=this.contractWrapper.getSigner();d(s);const n=await Promise.all(e.map((t=>E.parseAsync(t)))),i=await Promise.all(n.map((t=>this.mapPayloadToContractStruct(t)))),c=await Promise.all(i.map((t=>this.contractWrapper.signTypedData(s,{name:a,version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{MintRequest:S},t))));return e.map(((t,r)=>({payload:n[r],signature:c[r].toString()})))}async mapPayloadToContractStruct(t){const[r,a]=await Promise.all([u(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),e=W(t.quantity,a);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:e,price:r,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class V{featureName=t.name;get chainId(){return this._chainId}constructor(t,r,a){this.contractWrapper=t,this.storage=r,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await r(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await a(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[r,e]=await Promise.all([this.contractWrapper.getSignerAddress(),a(t)]);return await this.allowanceOf(r,e)}async allowanceOf(t,r){const e=await Promise.all([a(t),a(r)]);return await this.getValue(await this.contractWrapper.read("allowance",e))}transfer=e((async(t,r)=>s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([a(t),this.normalizeAmount(r)])})));transferFrom=e((async(t,r,e)=>s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([a(t),a(r),this.normalizeAmount(e)])})));setAllowance=e((async(t,r)=>s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([a(t),this.normalizeAmount(r)])})));transferBatch=e((async t=>{const r=new n(this.contractWrapper),e=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),a(t.toAddress)]))))).map((t=>{let[a,e]=t;return r.encode("transfer",[e,a])}));return s.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e]})}));mint=e((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=e((async(t,r)=>y(this.mintable,i).to.prepare(t,r)));async getMintTransaction(t,r){return y(this.mintable,i).getMintTransaction(t,r)}mintBatchTo=e((async t=>y(this.mintable?.batch,c).to.prepare(t)));burn=e((async t=>y(this.burnable,o).tokens.prepare(t)));burnFrom=e((async(t,r)=>y(this.burnable,o).from.prepare(t,r)));claim=e((async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r)));claimTo=e((async(t,r,a)=>y(this.droppable?.claim,p).to.prepare(t,r,a)));get claimConditions(){return y(this.droppable?.claim,p).conditions}get signature(){return y(this.signatureMintable,m)}async normalizeAmount(t){return async function(t,r){const a=await t.read("decimals",[]);return W(g.parse(r),a)}(this.contractWrapper,t)}async getValue(t){return await h(this.contractWrapper.getProvider(),this.getAddress(),l.from(t))}detectErc20Mintable(){if(f(this.contractWrapper,"ERC20"))return new R(this,this.contractWrapper)}detectErc20Burnable(){if(f(this.contractWrapper,"ERC20Burnable"))return new T(this,this.contractWrapper)}detectErc20Droppable(){if(f(this.contractWrapper,"ERC20ClaimConditionsV1")||f(this.contractWrapper,"ERC20ClaimConditionsV2")||f(this.contractWrapper,"ERC20ClaimPhasesV1")||f(this.contractWrapper,"ERC20ClaimPhasesV2"))return new M(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if(f(this.contractWrapper,"ERC20SignatureMintable"))return new z(this.contractWrapper)}}export{V as E,z as a};
//# sourceMappingURL=erc-20-9a18a51c.browser.esm-C1wHGVqi.js.map
