const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BdgVNXf3.js","assets/web3-vendor-D-smDdvq.js","assets/react-vendor-oRnAdrvc.js","assets/ui-vendor-DvZrbspg.js","assets/index-afkGx5Ck.css"])))=>i.map(i=>d[i]);
import{_ as t}from"./web3-vendor-D-smDdvq.js";import{W as r,J as e,B as a,y as i,c as s,z as n,ab as o,T as c,i as d,ad as p,_ as u,X as l,a2 as m,ae as f,af as g,ah as h,Y as w,a8 as y,a7 as A,H as W,E as C,G as v,ai as L,aj as k}from"./index-BdgVNXf3.js";import{c as b}from"./cleanCurrencyAddress-ded19cfe.browser.esm-CnKsRlUV.js";import{s as B}from"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import{g as I,h as T,i as S}from"./marketplace-e3129e2f.browser.esm-B9VhitKm.js";import{f as P,I as E,a as N}from"./QueryParams-32a56510.browser.esm-CIeLU7Il.js";import{E as O,R as F}from"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import{C as _,G as $}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{C as M}from"./contract-interceptor-d7b164a7.browser.esm-Dui4xQZ5.js";const x=(()=>n.object({assetContractAddress:v,tokenId:L,quantity:L.default(1),currencyContractAddress:v.default(k),pricePerToken:C,startTimestamp:F.default(new Date),endTimestamp:O,isReservedListing:n.boolean().default(!1)}))();let q=function(t){return t[t.UNSET=0]="UNSET",t[t.Created=1]="Created",t[t.Completed=2]="Completed",t[t.Cancelled=3]="Cancelled",t[t.Active=4]="Active",t[t.Expired=5]="Expired",t}({});class V{featureName=r.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new _(this.contractWrapper),this.encoder=new e(this.contractWrapper),this.interceptor=new M(this.contractWrapper),this.estimator=new $(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No listings exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllListings",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapListing(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No listings exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllValidListings",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapListing(t))))}async getListing(t){const r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(a.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await i(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(a.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await i(r)])}async currencyPriceForListing(t,r){const e=await this.validateListing(a.from(t)),s=await i(r);if(s===e.currencyContractAddress)return e.pricePerToken;if(!(await this.isCurrencyApprovedForListing(t,s)))throw new Error(`Currency ${s} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,s])}createListing=s((async t=>{const r=await x.parseAsync(t);await T(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await o(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),i=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(i)&&(r.startTimestamp=a.from(i));const s=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:b(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("NewListing",t?.logs)[0].args.listingId,receipt:t})});return s.setGasLimitMultiple(1.2),s}));createListingsBatch=s((async t=>{const r=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode())),e=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewListing",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))});return e.setGasLimitMultiple(1.2),e}));updateListing=s((async(t,r)=>{const e=await x.parseAsync(r);await T(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const a=await o(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress),i=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:b(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("UpdatedListing",t?.logs)[0].args.listingId,receipt:t})});return i.setGasLimitMultiple(1.2),i}));cancelListing=s((async t=>{const r=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]});return r.setGasLimitMultiple(1.2),r}));buyFromListing=s((async(t,r,e)=>{e&&(e=await i(e));const s=await this.validateListing(a.from(t)),{valid:n,error:o}=await this.isStillValidListing(s,r);if(!n)throw new Error(`Listing ${t} is no longer valid. ${o}`);const d=e||await this.contractWrapper.getSignerAddress(),p=a.from(r),u=a.from(s.pricePerToken).mul(p),l=await this.contractWrapper.getCallOverrides()||{};await B(this.contractWrapper,u,s.currencyContractAddress,l);const m=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,d,p,s.currencyContractAddress,u],overrides:l});return m.setGasLimitMultiple(1.2),m}));approveBuyerForReservedListing=s((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))throw new Error(`Buyer ${r} already approved for listing ${t}.`);{const e=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]});return e.setGasLimitMultiple(1.2),e}}));revokeBuyerApprovalForReservedListing=s((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r)){const e=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});return e.setGasLimitMultiple(1.2),e}throw new Error(`Buyer ${r} not approved for listing ${t}.`)}));approveCurrencyForListing=s((async(t,r,e)=>{const s=await this.validateListing(a.from(t)),n=await i(r);n===s.currencyContractAddress&&d(e===s.pricePerToken);const o=await this.contractWrapper.read("currencyPriceForListing",[t,n]);d(e===o);const p=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,e]});return p.setGasLimitMultiple(1.2),p}));revokeCurrencyApprovalForListing=s((async(t,r)=>{const e=await this.validateListing(a.from(t)),s=await i(r);if(s===e.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const n=await this.contractWrapper.read("currencyPriceForListing",[t,s]);d(!n.isZero());const o=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,s,a.from(0)]});return o.setGasLimitMultiple(1.2),o}));async validateListing(t){try{return await this.getListing(t)}catch(r){throw r}}async mapListing(t){let r=q.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.from(t.startTimestamp).gt(e)?q.Created:a.from(t.endTimestamp).lt(e)?q.Expired:q.Active;break;case 2:r=q.Completed;break;case 3:r=q.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await p(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:a.from(t.startTimestamp).toNumber(),asset:await P(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(r,e){if(!(await S(this.contractWrapper.getProvider(),this.getAddress(),r.assetContractAddress,r.tokenId,r.creatorAddress)))return{valid:!1,error:`Token '${r.tokenId}' from contract '${r.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),i=(await t((async()=>{const{default:t}=await import("./IERC165-ODxXmlQV.js");return{default:t}}),[])).default,s=new u(r.assetContractAddress,i,a),n=await s.supportsInterface(E),o=await s.supportsInterface(N);if(n){const e=(await t((async()=>{const{default:t}=await import("./index-BdgVNXf3.js").then((t=>t.dW));return{default:t}}),__vite__mapDeps([0,1,2,3,4]))).default,i=new u(r.assetContractAddress,e,a);let s;try{s=await i.ownerOf(r.tokenId)}catch(c){}const n=s?.toLowerCase()===r.creatorAddress.toLowerCase();return{valid:n,error:n?void 0:`Seller is not the owner of Token '${r.tokenId}' from contract '${r.assetContractAddress} anymore'`}}if(o){const i=(await t((async()=>{const{default:t}=await import("./index-BdgVNXf3.js").then((t=>t.dY));return{default:t}}),__vite__mapDeps([0,1,2,3,4]))).default,s=new u(r.assetContractAddress,i,a),n=(await s.balanceOf(r.creatorAddress,r.tokenId)).gte(e||r.quantity);return{valid:n,error:n?void 0:`Seller does not have enough balance of Token '${r.tokenId}' from contract '${r.assetContractAddress} to fulfill the listing`}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await i(r.seller);e=e.filter((r=>r.listingCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await i(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}const G=(()=>n.object({assetContractAddress:v,tokenId:L,quantity:L.default(1),currencyContractAddress:v.default(k),minimumBidAmount:C,buyoutBidAmount:C,timeBufferInSeconds:L.default(900),bidBufferBps:L.default(500),startTimestamp:F.default(new Date),endTimestamp:O}))();class j{featureName=l.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new _(this.contractWrapper),this.encoder=new e(this.contractWrapper),this.interceptor=new M(this.contractWrapper),this.estimator=new $(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No auctions exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllAuctions",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapAuction(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No auctions exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllValidAuctions",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapAuction(t))))}async getAuction(t){const r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(a.from(t));const r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==m)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){const r=await this.validateAuction(a.from(t)),e=await this.contractWrapper.read("getWinningBid",[t]),i=a.from(Math.floor(Date.now()/1e3)),s=a.from(r.endTimeInSeconds);if(i.gt(s)&&e._bidder!==m)return e._bidder;const n=new _(this.contractWrapper),o=(await n.getEvents("AuctionClosed")).find((r=>r.data.auctionId.eq(a.from(t))));if(!o)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return o.data.winningBidder}createAuction=s((async t=>{const r=G.parse(t);await T(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await o(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),i=await o(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),s=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(s)&&(r.startTimestamp=a.from(s));const n=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:b(r.currencyContractAddress),minimumBidAmount:i,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewAuction",t.logs)[0].args.auctionId,receipt:t})});return n.setGasLimitMultiple(1.2),n}));createAuctionsBatch=s((async t=>{const r=(await Promise.all(t.map((t=>this.createAuction.prepare(t))))).map((t=>t.encode())),e=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewAuction",t?.logs).map((r=>({id:r.args.auctionId,receipt:t})))});return e.setGasLimitMultiple(1.2),e}));buyoutAuction=s((async t=>{const r=await this.validateAuction(a.from(t)),e=await f(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,g(r.buyoutBidAmount,e.decimals))}));makeBid=s((async(t,r)=>{const e=await this.validateAuction(a.from(t)),i=await o(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(i.eq(a.from(0)))throw new Error("Cannot make a bid with 0 value");if(a.from(e.buyoutBidAmount).gt(0)&&i.gt(e.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const r=await this.isWinningBid(t,i);d(r)}else{const t=i,r=a.from(e.minimumBidAmount);d(t.gte(r))}const s=await this.contractWrapper.getCallOverrides()||{};await B(this.contractWrapper,i,e.currencyContractAddress,s);const n=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",overrides:s,args:[t,i]});return n.setGasLimitMultiple(1.2),n}));cancelAuction=s((async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");const r=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]});return r.setGasLimitMultiple(1.2),r}));closeAuctionForBidder=s((async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateAuction(a.from(t));try{const r=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[a.from(t)]});return r.setGasLimitMultiple(1.2),r}catch(i){throw i.message.includes("Marketplace: auction still active.")?new h(t.toString(),e.endTimeInSeconds.toString()):i}}));closeAuctionForSeller=s((async t=>{const r=await this.validateAuction(a.from(t));try{const r=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[a.from(t)]});return r.setGasLimitMultiple(1.2),r}catch(e){throw e.message.includes("Marketplace: auction still active.")?new h(t.toString(),r.endTimeInSeconds.toString()):e}}));executeSale=s((async t=>{const r=await this.validateAuction(a.from(t));try{const r=await this.getWinningBid(t);d(r,"No winning bid found");const e=this.encoder.encode("collectAuctionPayout",[t]),a=this.encoder.encode("collectAuctionTokens",[t]),i=c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[e,a]]});return i.setGasLimitMultiple(1.2),i}catch(e){throw e.message.includes("Marketplace: auction still active.")?new h(t.toString(),r.endTimeInSeconds.toString()):e}}));async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,e,i]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(a.from(t))]),s=e?a.from(e.bidAmount):a.from(i.minimumBidAmount),n=s.add(s.mul(r).div(1e4));return p(this.contractWrapper.getProvider(),i.currencyContractAddress,n)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw r}}async mapAuction(t){let r=q.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.from(t.startTimestamp).gt(e)?q.Created:a.from(t.endTimestamp).lt(e)?q.Expired:q.Active;break;case 2:r=q.Completed;break;case 3:r=q.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await p(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await p(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:a.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:a.from(t.bidBufferBps).toNumber(),startTimeInSeconds:a.from(t.startTimestamp).toNumber(),endTimeInSeconds:a.from(t.endTimestamp).toNumber(),asset:await P(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){const s=await i(r),n=await i(e);return{auctionId:t,bidderAddress:s,currencyContractAddress:n,bidAmount:a,bidAmountCurrencyValue:await p(this.contractWrapper.getProvider(),n,a)}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await i(r.seller);e=e.filter((r=>r.auctionCreator.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await i(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}const R=(()=>n.object({assetContractAddress:v,tokenId:L,quantity:L.default(1),currencyContractAddress:v.default(k),totalPrice:C,endTimestamp:O}))();class D{featureName=w.name;constructor(t,r){this.contractWrapper=t,this.storage=r,this.events=new _(this.contractWrapper),this.encoder=new e(this.contractWrapper),this.interceptor=new M(this.contractWrapper),this.estimator=new $(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No offers exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllOffers",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapOffer(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=a.from(t?.start||0).toNumber(),i=r.toNumber();if(0===i)throw new Error("No offers exist on the contract.");let s=[];s=(await I(e,i,((t,r)=>this.contractWrapper.read("getAllValidOffers",[t,r])))).flat();const n=await this.applyFilter(s,t);return await Promise.all(n.map((t=>this.mapOffer(t))))}async getOffer(t){const r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}makeOffer=s((async t=>{const r=await R.parseAsync(t),e=await this.contractWrapper.getChainID(),a=y(r.currencyContractAddress)?A[e].wrapped.address:r.currencyContractAddress,i=await o(this.contractWrapper.getProvider(),r.totalPrice,a),s=await this.contractWrapper.getCallOverrides();return await B(this.contractWrapper,i,a,s),c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:i,expirationTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewOffer",t?.logs)[0].args.offerId,receipt:t})})}));cancelOffer=s((async t=>c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})));acceptOffer=s((async t=>{const r=await this.validateOffer(a.from(t)),{valid:e,error:i}=await this.isStillValidOffer(r);if(!e)throw new Error(`Offer ${t} is no longer valid. ${i}`);const s=await this.contractWrapper.getCallOverrides()||{};return await T(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:s})}));async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw r}}async mapOffer(t){let r=q.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=a.from(t.expirationTimestamp).lt(e)?q.Expired:q.Active;break;case 2:r=q.Completed;break;case 3:r=q.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await p(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await P(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:a.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(r){if(a.from(Math.floor(Date.now()/1e3)).gt(r.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${r.id} has expired`};const e=await this.contractWrapper.getChainID(),i=y(r.currencyContractAddress)?A[e].wrapped.address:r.currencyContractAddress,s=this.contractWrapper.getProvider(),n=(await t((async()=>{const{default:t}=await import("./index-BdgVNXf3.js").then((t=>t.dV));return{default:t}}),__vite__mapDeps([0,1,2,3,4]))).default,o=new W(s,i,n,{},this.storage);if((await o.read("balanceOf",[r.offerorAddress])).lt(r.totalPrice))return{valid:!1,error:`Offeror ${r.offerorAddress} doesn't have enough balance of token ${i}`};return(await o.read("allowance",[r.offerorAddress,this.getAddress()])).lt(r.totalPrice)?{valid:!1,error:`Offeror ${r.offerorAddress} hasn't approved enough amount of token ${i}`}:{valid:!0,error:""}}async applyFilter(t,r){let e=[...t];if(r){if(r.offeror){const t=await i(r.offeror);e=e.filter((r=>r.offeror.toString().toLowerCase()===t?.toString().toLowerCase()))}if(r.tokenContract){const t=await i(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===t?.toString().toLowerCase()))}void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString())))}return r?.count&&r.count<e.length?e.slice(0,r.count):e}}export{V as M,j as a,D as b};
//# sourceMappingURL=marketplacev3-offers-ce1f096b.browser.esm-DWLRe7HE.js.map
