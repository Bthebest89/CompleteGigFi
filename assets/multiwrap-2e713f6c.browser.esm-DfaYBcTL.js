import{ak as t,H as r,A as e,al as s,J as a,ae as o,af as n,c,y as i,T as p,ab as d}from"./index-BdgVNXf3.js";import{h}from"./hasERC20Allowance-654a940b.browser.esm-Cz-jkTEv.js";import{i as w}from"./marketplace-e3129e2f.browser.esm-B9VhitKm.js";import{u as m}from"./QueryParams-32a56510.browser.esm-CIeLU7Il.js";import{a as l,b as k,G as f,C as u}from"./contract-appuri-5c40af52.browser.esm-Bz6oVDxP.js";import{C as g,a as A}from"./contract-owner-49e75547.browser.esm-_SCqISV8.js";import{C as W}from"./contract-roles-71988d2e.browser.esm-CpZiDLHX.js";import{S as b}from"./erc-721-standard-4c4125d2.browser.esm-CwkY8p4N.js";import"./web3-vendor-D-smDdvq.js";import"./react-vendor-oRnAdrvc.js";import"./ui-vendor-DvZrbspg.js";import"./setErc20Allowance-7f76f677.browser.esm-DUVYy-Mo.js";import"./index-voFwA1yT.js";import"./treeify-PLB7ybit.js";import"./assertEnabled-d1700f0b.browser.esm-C0-eUoBY.js";import"./erc-721-27306550.browser.esm-BS-g0s5y.js";import"./drop-claim-conditions-e6f2abbf.browser.esm-DUin9XFx.js";class v extends b{static contractRoles=t;constructor(t,o,n){let c=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0;super(arguments.length>6&&void 0!==arguments[6]?arguments[6]:new r(t,o,c,arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},n),n,i),this.abi=e.parse(c||[]),this.metadata=new l(this.contractWrapper,s,this.storage),this.app=new k(this.contractWrapper,this.metadata,this.storage),this.roles=new W(this.contractWrapper,v.contractRoles),this.encoder=new a(this.contractWrapper),this.estimator=new f(this.contractWrapper),this.events=new u(this.contractWrapper),this.royalties=new g(this.contractWrapper,this.metadata),this.owner=new A(this.contractWrapper)}async getWrappedContents(t){const r=await this.contractWrapper.read("getWrappedContents",[t]),e=[],s=[],a=[];for(const c of r)switch(c.tokenType){case 0:{const t=await o(this.contractWrapper.getProvider(),c.assetContract);e.push({contractAddress:c.assetContract,quantity:n(c.totalAmount,t.decimals)});break}case 1:s.push({contractAddress:c.assetContract,tokenId:c.tokenId});break;case 2:a.push({contractAddress:c.assetContract,tokenId:c.tokenId,quantity:c.totalAmount.toString()})}return{erc20Tokens:e,erc721Tokens:s,erc1155Tokens:a}}wrap=c((async(t,r,e)=>{const[s,a,o]=await Promise.all([m(r,this.storage),this.toTokenStructList(t),i(e||await this.contractWrapper.getSignerAddress())]);return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"wrap",args:[a,s,o],parse:t=>{const r=this.contractWrapper.parseLogs("TokensWrapped",t?.logs);if(0===r.length)throw new Error("TokensWrapped event not found");const e=r[0].args.tokenIdOfWrappedToken;return{id:e,receipt:t,data:()=>this.get(e)}}})}));unwrap=c((async(t,r)=>{const e=await i(r||await this.contractWrapper.getSignerAddress());return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:"unwrap",args:[t,e]})}));async toTokenStructList(t){const r=[],e=this.contractWrapper.getProvider(),s=await this.contractWrapper.getSignerAddress();if(t.erc20Tokens)for(const a of t.erc20Tokens){const t=await d(e,a.quantity,a.contractAddress);if(!(await h(this.contractWrapper,a.contractAddress,t)))throw new Error(`ERC20 token with contract address "${a.contractAddress}" does not have enough allowance to transfer.\n\nYou can set allowance to the multiwrap contract to transfer these tokens by running:\n\nawait sdk.getToken("${a.contractAddress}").setAllowance("${this.getAddress()}", ${a.quantity});\n\n`);r.push({assetContract:a.contractAddress,totalAmount:t,tokenId:0,tokenType:0})}if(t.erc721Tokens)for(const a of t.erc721Tokens){if(!(await w(this.contractWrapper.getProvider(),this.getAddress(),a.contractAddress,a.tokenId,s)))throw new Error(`ERC721 token "${a.tokenId}" with contract address "${a.contractAddress}" is not approved for transfer.\n\nYou can give approval the multiwrap contract to transfer this token by running:\n\nawait sdk.getNFTCollection("${a.contractAddress}").setApprovalForToken("${this.getAddress()}", ${a.tokenId});\n\n`);r.push({assetContract:a.contractAddress,totalAmount:0,tokenId:a.tokenId,tokenType:1})}if(t.erc1155Tokens)for(const a of t.erc1155Tokens){if(!(await w(this.contractWrapper.getProvider(),this.getAddress(),a.contractAddress,a.tokenId,s)))throw new Error(`ERC1155 token "${a.tokenId}" with contract address "${a.contractAddress}" is not approved for transfer.\n\nYou can give approval the multiwrap contract to transfer this token by running:\n\nawait sdk.getEdition("${a.contractAddress}").setApprovalForAll("${this.getAddress()}", true);\n\n`);r.push({assetContract:a.contractAddress,totalAmount:a.quantity,tokenId:a.tokenId,tokenType:2})}return r}async prepare(t,r,e){return p.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:r,overrides:e})}async call(t,r,e){return this.contractWrapper.call(t,r,e)}}export{v as Multiwrap};
//# sourceMappingURL=multiwrap-2e713f6c.browser.esm-DfaYBcTL.js.map
