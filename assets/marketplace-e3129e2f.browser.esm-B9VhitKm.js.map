{"version":3,"mappings":"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","names":["async","isTokenApprovedForTransfer","provider","transferrerContractAddress","assetContract","tokenId","owner","ERC165Abi","__vitePreload","default","__vite_default__","import","__VITE_PRELOAD__","erc165","Contract","isERC721","isERC1155","Promise","all","supportsInterface","InterfaceId_IERC721","InterfaceId_IERC1155","ERC721Abi","then","n","dW","asset","isApprovedForAll","approvedAddress","getApproved","e","toLowerCase","ERC1155Abi","dY","err","handleTokenApproval","contractWrapper","marketplaceAddress","from","ContractWrapper","getSignerOrProvider","options","storage","read","sendTransaction","Error","validateNewListingParam","param","invariant","undefined","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","startTimestamp","quantity","type","reservePricePerToken","mapOffer","listingId","offer","quantityDesired","pricePerToken","currencyContractAddress","currency","buyerAddress","offeror","quantityWanted","currencyValue","fetchCurrencyValue","mul","isWinningBid","winningPrice","newBidPrice","bidBuffer","BigNumber","eq","sub","MAX_BPS","div","gte","getAllInBatches","start","end","fn","batches","DEFAULT_QUERY_ALL_COUNT","push"],"ignoreList":[0],"sources":["../../node_modules/@thirdweb-dev/sdk/dist/marketplace-e3129e2f.browser.esm.js"],"sourcesContent":["import { Contract, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { I as InterfaceId_IERC721, a as InterfaceId_IERC1155, D as DEFAULT_QUERY_ALL_COUNT } from './QueryParams-32a56510.browser.esm.js';\nimport { cs as ContractWrapper, dE as MAX_BPS } from './index-33cd3415.browser.esm.js';\nimport { a as fetchCurrencyValue } from './fetchCurrencyValue-32d08b05.browser.esm.js';\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns  True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(assetContract, ERC721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(assetContract, ERC1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper - The contract wrapper to use\n * @param marketplaceAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param from - The address of the account that owns the token.\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const [isERC721, isERC1155] = await Promise.all([erc165.read(\"supportsInterface\", [InterfaceId_IERC721]), erc165.read(\"supportsInterface\", [InterfaceId_IERC1155])]);\n  // check for token approval\n  if (isERC721) {\n    const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer - The offer to map\n * @returns  An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\nexport { isWinningBid as a, getAllInBatches as g, handleTokenApproval as h, isTokenApprovedForTransfer as i, mapOffer as m, validateNewListingParam as v };\n"],"file":"assets/marketplace-e3129e2f.browser.esm-B9VhitKm.js"}