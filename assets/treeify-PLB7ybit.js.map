{"version":3,"file":"treeify-PLB7ybit.js","sources":["../../node_modules/buffer-reverse/index.js","../../node_modules/treeify/treeify.js"],"sourcesContent":["module.exports = function reverse (src) {\n  var buffer = new Buffer(src.length)\n\n  for (var i = 0, j = src.length - 1; i <= j; ++i, --j) {\n    buffer[i] = src[j]\n    buffer[j] = src[i]\n  }\n\n  return buffer\n}\n","//     treeify.js\n//     Luke Plaster <notatestuser@gmail.com>\n//     https://github.com/notatestuser/treeify.js\n\n// do the universal module definition dance\n(function (root, factory) {\n\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.treeify = factory();\n  }\n\n}(this, function() {\n\n  function makePrefix(key, last) {\n    var str = (last ? '└' : '├');\n    if (key) {\n      str += '─ ';\n    } else {\n      str += '──┐';\n    }\n    return str;\n  }\n\n  function filterKeys(obj, hideFunctions) {\n    var keys = [];\n    for (var branch in obj) {\n      // always exclude anything in the object's prototype\n      if (!obj.hasOwnProperty(branch)) {\n        continue;\n      }\n      // ... and hide any keys mapped to functions if we've been told to\n      if (hideFunctions && ((typeof obj[branch])===\"function\")) {\n        continue;\n      }\n      keys.push(branch);\n    }\n    return keys;\n  }\n\n  function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {\n    var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);\n\n    if (lastStatesCopy.push([ root, last ]) && lastStates.length > 0) {\n      // based on the \"was last element\" states of whatever we're nested within,\n      // we need to append either blankness or a branch to our line\n      lastStates.forEach(function(lastState, idx) {\n        if (idx > 0) {\n          line += (lastState[1] ? ' ' : '│') + '  ';\n        }\n        if ( ! circular && lastState[0] === root) {\n          circular = true;\n        }\n      });\n\n      // the prefix varies based on whether the key contains something to show and\n      // whether we're dealing with the last element in this collection\n      line += makePrefix(key, last) + key;\n\n      // append values and the circular reference indicator\n      showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);\n      circular && (line += ' (circular ref.)');\n\n      callback(line);\n    }\n\n    // can we descend into the next item?\n    if ( ! circular && typeof root === 'object') {\n      var keys = filterKeys(root, hideFunctions);\n      keys.forEach(function(branch){\n        // the last key is always printed with a different prefix, so we'll need to know if we have it\n        lastKey = ++index === keys.length;\n\n        // hold your breath for recursive action\n        growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);\n      });\n    }\n  };\n\n  // --------------------\n\n  var Treeify = {};\n\n  // Treeify.asLines\n  // --------------------\n  // Outputs the tree line-by-line, calling the lineCallback when each one is available.\n\n  Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {\n    /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */\n    var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;\n    growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);\n  };\n\n  // Treeify.asTree\n  // --------------------\n  // Outputs the entire tree, returning it as a string with line breaks.\n\n  Treeify.asTree = function(obj, showValues, hideFunctions) {\n    var tree = '';\n    growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {\n      tree += line + '\\n';\n    });\n    return tree;\n  };\n\n  // --------------------\n\n  return Treeify;\n\n}));\n"],"names":["bufferReverse","src","buffer","Buffer","length","i","j","exports","makePrefix","key","last","str","filterKeys","obj","hideFunctions","keys","branch","hasOwnProperty","push","growBranch","root","lastStates","showValues","callback","lastKey","circular","line","index","lastStatesCopy","slice","forEach","lastState","idx","Date","Treeify","lineCallback","tree","factory"],"mappings":"sDAAA,IAAAA,EAAiB,SAAkBC,GAGjC,IAFA,IAAIC,EAAS,IAAIC,OAAOF,EAAIG,QAEnBC,EAAI,EAAGC,EAAIL,EAAIG,OAAS,EAAGC,GAAKC,IAAKD,IAAKC,EACjDJ,EAAOG,GAAKJ,EAAIK,GAChBJ,EAAOI,GAAKL,EAAII,GAGlB,OAAOH,CACT,sCCDIK,QAOI,WAEN,SAASC,EAAWC,EAAKC,GACvB,IAAIC,EAAOD,EAAO,IAAM,IAMxB,OAJEC,GADEF,EACK,KAEA,MAKX,SAASG,EAAWC,EAAKC,GACvB,IAAIC,EAAO,GACX,IAAK,IAAIC,KAAUH,EAEZA,EAAII,eAAeD,KAIpBF,GAAyC,mBAAfD,EAAIG,IAGlCD,EAAKG,KAAKF,IAEZ,OAAOD,EAGT,SAASI,EAAWV,EAAKW,EAAMV,EAAMW,EAAYC,EAAYR,EAAeS,GAC1E,IAA0BC,EAASC,EAA/BC,EAAO,GAAIC,EAAQ,EAAsBC,EAAiBP,EAAWQ,MAAM,GA0B/E,GAxBID,EAAeV,KAAK,CAAEE,EAAMV,KAAWW,EAAWjB,OAAS,IAG7DiB,EAAWS,SAAQ,SAASC,EAAWC,GACjCA,EAAM,IACRN,IAASK,EAAU,GAAK,IAAM,KAAO,MAEhCN,GAAYM,EAAU,KAAOX,IAClCK,GAAW,EAErB,IAIMC,GAAQlB,EAAWC,EAAKC,GAAQD,EAGhCa,IAA+B,iBAATF,GAAqBA,aAAgBa,QAAUP,GAAQ,KAAON,GACpFK,IAAaC,GAAQ,oBAErBH,EAASG,KAIJD,GAA4B,iBAATL,EAAmB,CAC3C,IAAIL,EAAOH,EAAWQ,EAAMN,GAC5BC,EAAKe,SAAQ,SAASd,GAEpBQ,IAAYG,IAAUZ,EAAKX,OAG3Be,EAAWH,EAAQI,EAAKJ,GAASQ,EAASI,EAAgBN,EAAYR,EAAeS,EAC7F,IAEA,CAIE,IAAIW,EAAU,CAMdA,QAAkB,SAASrB,EAAKS,EAAYR,EAAeqB,GAGzDhB,EAAW,IAAKN,GAAK,EAAO,GAAIS,EADgB,mBAAlBR,GAA+BA,EACCqB,GAAgBrB,EAC/E,EAMDoB,OAAiB,SAASrB,EAAKS,EAAYR,GACzC,IAAIsB,EAAO,GAIX,OAHAjB,EAAW,IAAKN,GAAK,EAAO,GAAIS,EAAYR,GAAe,SAASY,GAClEU,GAAQV,EAAO,IACrB,IACWU,CACR,GAID,OAAOF,CAET,CAxGqBG","x_google_ignoreList":[0,1]}